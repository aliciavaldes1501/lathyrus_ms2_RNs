---
title: "Lathyrus ms2: Selection on reaction norms - multivariate modeling for phenotypic selection on plasticity"
output:
  pdf_document:
    toc: yes
    toc_depth: 4
editor_options:
  chunk_output_type: inline
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(warning = FALSE, message = FALSE) 
```

```{r load packages, include=FALSE}
library(knitr)
library(pander)
library(tidyverse)
library(ggthemes)
library(broom)
library(gridExtra)
library(lme4)
library(lmerTest)
library(MuMIn)
library(ggrepel)
library(car)
library(effects)
library(RColorBrewer)
library(MCMCglmm)
library(blme)
library(beepr)
library(lmerTest)
library(RPushbullet)
library(glmmTMB)
library(ggeffects)
```

```{r Define ggplot themes, include=FALSE}
my_theme <- function(){
  theme_base()+theme(plot.background=element_rect(fill="white", colour=NA))+
  theme(legend.position="none")+theme(text=element_text(family="serif"))+
  theme(plot.title = element_text(hjust =-0.06))
}
my_theme_legend <- function(){
  theme_base()+theme(plot.background=element_rect(fill="white", colour=NA))+
  theme(text=element_text(family="serif"))+
  theme(plot.title = element_text(hjust =-0.06))
}
```

```{r summarySE function, include=FALSE}
## Gives count, mean, standard deviation, standard error of the mean, and confidence interval (default 95%).
##   data: a data frame.
##   measurevar: the name of a column that contains the variable to be summariezed
##   groupvars: a vector containing names of columns that contain grouping variables
##   na.rm: a boolean that indicates whether to ignore NA's
##   conf.interval: the percent range of the confidence interval (default is 95%)
summarySE <- function(data=NULL, measurevar, groupvars=NULL, na.rm=FALSE,
                      conf.interval=.95, .drop=TRUE) {
  library(plyr)
  
  # New version of length which can handle NA's: if na.rm==T, don't count them
  length2 <- function (x, na.rm=FALSE) {
    if (na.rm) sum(!is.na(x))
    else       length(x)
  }
  
  # This does the summary. For each group's data frame, return a vector with
  # N, mean, and sd
  datac <- ddply(data, groupvars, .drop=.drop,
                 .fun = function(xx, col) {
                   c(N    = length2(xx[[col]], na.rm=na.rm),
                     mean = mean   (xx[[col]], na.rm=na.rm),
                     sd   = sd     (xx[[col]], na.rm=na.rm)
                   )
                 },
                 measurevar
  )
  
  # Rename the "mean" column    
  datac <- rename(datac, c("mean" = measurevar))
  
  datac$se <- datac$sd / sqrt(datac$N)  # Calculate standard error of the mean
  
  # Confidence interval multiplier for standard error
  # Calculate t-statistic for confidence interval: 
  # e.g., if conf.interval is .95, use .975 (above/below), and use df=N-1
  ciMult <- qt(conf.interval/2 + .5, datac$N-1)
  datac$ci <- datac$se * ciMult
  
  return(datac)
}
```

```{r function to check for overdispersion, include=FALSE}
overdisp_fun <- function(model) {
    rdf <- df.residual(model)
    rp <- residuals(model,type="pearson")
    Pearson.chisq <- sum(rp^2)
    prat <- Pearson.chisq/rdf
    pval <- pchisq(Pearson.chisq, df=rdf, lower.tail=FALSE)
    c(chisq=Pearson.chisq,ratio=prat,rdf=rdf,p=pval)
}
```

```{r}
# function to calculate vif for MCMCglmm
# Taken from https://github.com/aufrank/R-hacks/blob/master/MCMCglmm-utils.R#L2
vif.MCMCglmm <- function (fit, intercept.columns = c(1)) {
    nF <- fit$Fixed$nfl
    v <- cov(as.matrix(fit$X[,1:nF]))
    nam <- colnames(fit$Sol[,1:nF])

    v <- v[-intercept.columns, -intercept.columns, drop = FALSE]
    nam <- nam[-intercept.columns]
    
    d <- diag(v)^0.5
    v <- diag(solve(v/(d %o% d)))
    names(v) <- nam
    v
}
```


```{r load models, include=FALSE}
# Load previously run models so that they are not run when knitting (takes long time)
load("C:/Users/User/Dropbox/SU/Projects/lathyrus/lathyrus_ms2/code/objects/univar.FFD.RData")
load("C:/Users/User/Dropbox/SU/Projects/lathyrus/lathyrus_ms2/code/objects/univar.FFD_RR.RData")
load("C:/Users/User/Dropbox/SU/Projects/lathyrus/lathyrus_ms2/code/objects/modelBV_RR10.RData")
load("C:/Users/User/Dropbox/SU/Projects/lathyrus/lathyrus_ms2/code/objects/modelBV_RR12.RData")
load("C:/Users/User/Dropbox/SU/Projects/lathyrus/lathyrus_ms2/code/objects/modelBV_RR14.RData")
load("C:/Users/User/Dropbox/SU/Projects/lathyrus/lathyrus_ms2/code/objects/modelBV_RR15.RData")
load("C:/Users/User/Dropbox/SU/Projects/lathyrus/lathyrus_ms2/code/objects/model_years_abs_bayes.RData")
load("C:/Users/User/Dropbox/SU/Projects/lathyrus/lathyrus_ms2/code/objects/model_years_abs_slope_bayes.RData")
load("C:/Users/User/Dropbox/SU/Projects/lathyrus/lathyrus_ms2/code/objects/model_years_abs_temp_bayes.RData")
load("C:/Users/User/Dropbox/SU/Projects/lathyrus/lathyrus_ms2/code/objects/model_years_abs_temp_slope_bayes.RData")
load("C:/Users/User/Dropbox/SU/Projects/lathyrus/lathyrus_ms2/code/objects/model_years_abs_temp_slope_vol_bayes.RData")
load("C:/Users/User/Dropbox/SU/Projects/lathyrus/lathyrus_ms2/code/objects/model_years_abs_slope_vol_bayes.RData")
load("C:/Users/User/Dropbox/SU/Projects/lathyrus/lathyrus_ms2/code/objects/model_years_abs_temp_slope_vol_int_bayes.RData")
```

# Data preparation

The data (file "data_5yrs") contains information on 1162 flowering events from 163 different individuals of Lathyrus vernus during two periods (1987-1996 and 2006-2017). This is a subset of a larger data set from which we selected individuals that had at least 5 years of data on first flowering date, in order to be able to accurately estimate reaction norms. 

```{r data prep}
# Read data
data_5yrs<-read.csv(
  "C:/Users/User/Dropbox/SU/Projects/lathyrus/lathyrus_ms2/data/data_5yrs.csv",
  header=T,sep=",",dec=".")  

# Have a look at the data
head(data_5yrs) 
str(data_5yrs)
```

Variables:

* Year
* Id: individual
* FFD: first flowering date (as number of days after vernal equinox, so lower values mean earlier flowering), our trait of interest
* n_fl: number of flowers
* shoot_vol: shoot volume (measure of plant size)
* n_intact_seeds: number of intact (i.e. non predated) seeds, our fitness measure
* mean_4: mean daily temperature of April
* n_years_FFD: Number of years when we have data for FFD
* n_years_fl: Number of years when the plant has flowered (could be larger than n_years_FFD if no data on FFD is available for any of the flowering years)
* n_years_life = Number of years when the plant was alive (plants can skip flowering in some years)

The temperature variable (mean daily temperature April) is mean-centered (substracting the mean), so the intercepts reflect average values for the population and individuals. From here on, we use this mean-centred temperature (cmean_4).

```{r center temp}
data_5yrs$cmean_4<-scale(data_5yrs$mean_4,center=T,scale=F)
```

# Univariate MCMCglmm models

Code based on Arnold et al. 2019 Phil. Trans. R. Soc. B. 

```{r sc and priors}
# Scaling factor for MCMCglmm iterations
sc <- 1000 # Increase this parameter for longer runs

priorUV2 <- list(G = list(G1 = list(V = diag(1), nu = 1),  # for random effect of year
                          G2 = list(V = diag(1), nu = 1)), # for random effect of id 
                 R = list(R1 = list(V = diag(1), nu = 2))) 
priorUV2_RR <- list(G = list(G1 = list(V = diag(1), nu = 1),  # other random effect (YEAR)
                             G2 = list(V = diag(2), nu = 1)),  
                        # ^ 2x2 variance-covariance matrix for var in slopes + intercepts
                    R = list(R1 = list(V = diag(1), nu = 2)))  
```

## FFD with random effects of year and individual-intercept 

```{r MCMCglmm univar 1, eval=FALSE, include=TRUE}
univar.FFD <- MCMCglmm(FFD ~ cmean_4,
                     random = ~year + id,
                     rcov = ~units,
                     data = data_5yrs,
                     prior = priorUV2, 
                     family = "gaussian",
                     nitt = 2100 * sc, thin = sc, burnin = 100 * sc, verbose = F)
# nitt = burnin + thin*(n samples to keep)
# Aim to store 2000 iterations
save(univar.FFD,file="C:/Users/User/Dropbox/SU/Projects/lathyrus/lathyrus_ms2/code/objects/univar.FFD.RData")
```

```{r MCMCglmm univar 2}
summary(univar.FFD)
```

## Random regression for FFD, including random effects of individual slopes and covariance between intercept and slope

```{r MCMCglmm univar 3, eval=FALSE, include=TRUE}
univar.FFD_RR <- MCMCglmm(FFD ~ cmean_4,
                        random = ~year + us(1 + cmean_4):id,
                        rcov = ~units,
                        data = data_5yrs,
                        prior = priorUV2_RR, 
                        family = "gaussian",
                        nitt = 2100 * sc, thin = sc, burnin = 100 * sc, verbose = F,pr=T) 
# pr= T saves the posterior distribution of the individual random effects
# (analagous to the BLUP from the LMM)
save(univar.FFD_RR,file="C:/Users/User/Dropbox/SU/Projects/lathyrus/lathyrus_ms2/code/objects/univar.FFD_RR.RData")
```


```{r MCMCglmm univar 4}
summary(univar.FFD_RR)
```

### Extract BLUPs from this model

Code adapted from Houslay & Wilson 2017 Behav. Ecol. Code for graphs based on Arnold et al. 2019 Phil. Trans. R. Soc. B.  

```{r extract BLUPs, fig.height=5, fig.width=6, message=FALSE, warning=FALSE}
BLUPs_MCMC <- tibble(Trait = attr(colMeans(univar.FFD_RR$Sol), "names"),
                          Value = colMeans(univar.FFD_RR$Sol)) %>%
  filter(grepl("id", Trait))%>% # Select only id intercepts and slopes
  mutate(type=ifelse(grepl("Intercept",Trait),"intercept","slope"))%>%
  mutate(id=sub(".*id.", "", Trait))%>%
  select(-Trait)%>%
  spread(., type, Value) # Convert from long to wide
```

Correlation among intercepts and slopes

```{r corr1, fig.height=2.5, fig.width=6}
univar.FFD_RR_intslope <- 
  univar.FFD_RR$VCV[,"cmean_4:(Intercept).id"]/
(sqrt(univar.FFD_RR$VCV[,"(Intercept):(Intercept).id"])*
sqrt(univar.FFD_RR$VCV[,"cmean_4:cmean_4.id"]))
plot(univar.FFD_RR_intslope)
posterior.mode(univar.FFD_RR_intslope)
HPDinterval(univar.FFD_RR_intslope) 
```

High correlation among BLUPs for intercepts and slopes.

BLUPs represent the response of a given id to the fixed effect of temperature as the difference between that id’s predicted response and the population-level average predicted response.

The BLUP intercept term indicates the difference in id elevation relative to the population-average, so more positive values of BLUP intercept indicate that the id’s reaction norm occurs above the population-level average and negative values are below the population-level average. The BLUP intercept values are not a measure of plasticity, but these values may be correlated with BLUP slope values and otherwise may be a parameter of interest for comparing among ids.

```{r BLUPs1, echo=FALSE, fig.height=4, fig.width=10}
ggplot(BLUPs_MCMC, aes(id, intercept)) + 
  geom_point(aes(group = id, colour = id), size = 4, alpha = 0.5) + 
  ylab("BLUP intercept estimate") +
  geom_hline(yintercept = 0, lty = 2) + my_theme() +
  theme(axis.text.x = element_blank())
```

The BLUP slope estimate is the difference in slope (relative steepness of change) between the population-level average response and the response of the id. Here, that is the difference in slope of FFD for each value of temperature relative to the population-level average slope.

```{r BLUPs2, echo=FALSE, fig.height=4, fig.width=10}
ggplot(BLUPs_MCMC, aes(id, slope)) + 
  geom_point(aes(group = id, colour = id), size = 4, alpha = 0.5) + 
  ylab("Plasticity (BLUP slope estimate)") +
  geom_hline(yintercept = 0, lty = 2) + my_theme() +
  theme(axis.text.x = element_blank())
```

The BLUP intercept and slope estimates are highly correlated. This positive relationship can clearly be seen when plotting the BLUP slope estimate against the BLUP intercept estimate. Ids with the most positive BLUP slope estimate have the highest positive intercept, and have the least plasticity across growth temperatures. 

```{r BLUPs_all20, echo=FALSE, fig.height=4, fig.width=4}
ggplot(BLUPs_MCMC, aes(intercept, slope)) +
  geom_point(aes(group = id, colour = id), size = 4, alpha = 0.5) +
  xlab("BLUP intercept estimate") +
  ylab("BLUP slope estimate") + my_theme()
```

We can rank the BLUPs in order: sorting BLUPs by slope of most to least plastic. Because the population-level average response is negative, the most negative BLUP slope estimates represent steeper reaction norm slopes and hence greater plasticity, and more positive BLUP slope estimates represent flatter reaction norms and less plasticity in FFD in response to temperatures.

```{r BLUPs_all21, echo=FALSE, fig.height=4, fig.width=10}
BLUPs_MCMC$id_ordered <- factor(BLUPs_MCMC$id,levels = BLUPs_MCMC$id[order(BLUPs_MCMC$slope)])
ggplot(BLUPs_MCMC, aes(id_ordered, slope)) +
  geom_bar(stat = "identity", aes(group = id, fill = id)) +
  xlab("Id (in ranked order of plasticity)") +
  ylab("Plasticity (BLUP slope estimate)") +
  my_theme() + theme(axis.text.x = element_blank())
```

Important note! BLUPs are single point estimates that do not have associated measures of uncertainty. Therefore, it is dangerous to derive statistics or make formal interpretation of plasticity based on them without properly accounting for estimation uncertainty. 

# Bivariate MCMCglmm models (global)

Code based on Arnold et al. 2019 Phil. Trans. R. Soc. B. 

Fitting bivariate models of fitness and FFD, with random regressions for individuals, using a Poisson distribution for fitness (and using absolute fitness). Using mean April temperature and individuals with at least 5 years of data. Using either mean fitness per year of life or mean fitness per flowering event. Including / not including mean shoot volume over all  years with available data (with an effect on fitness) as a condition variable. 

Data preparation

```{r data prep MCMCglmm}
data_5yrs_total<-data_5yrs %>%
  group_by(id)%>%
  summarise(mean_fitness_life=sum(n_intact_seeds)/mean(n_years_life),
            # Mean fitness per year of life = sum fitness / n years alive 
            mean_fitness_fl=sum(n_intact_seeds)/mean(n_years_fl))%>%
  # Mean fitness per fl event = sum fitness / n years when each id flowered
   arrange(.,id) # Order by id

 with(data_5yrs_total,cor(mean_fitness_life,mean_fitness_fl))  # Highly correlated

# Read shoot volume data
shoot_vol<-read.csv(
  "C:/Users/User/Dropbox/SU/Projects/lathyrus/lathyrus_ms2/data/shoot_vol.csv",
  header=T,sep=",",dec=".")  

# Have a look at shoot volume data
head(shoot_vol) 
str(shoot_vol)

# This file contains values of shoot volume for all ids/years 
# (including also yrs when an id was not flowering)

shoot_vol_means<-shoot_vol%>%
  group_by(id)%>%
  summarise(shoot_vol_mean=mean(shoot_vol)) # Mean of all available values 

# Join shoot volume data
(data_5yrs_total<-data_5yrs_total%>%right_join(shoot_vol_means))
```

## Mean fitness per year of life

### With no condition variable

Stack data:

```{r stack data 1}
# Create a single data-set "data.stack10", with single column at start
# to index observations
data.stack10 <- c()
data.stack10$Obs <- 1:(163 + 1162)
data.stack10$id <- c(as.character(data_5yrs_total$id),as.character(data_5yrs$id)) 
# ids in alphabetical order

# Add first_yr to total data + 
# Year column is only relevant for FFD, but is set to first_yr for fitness values
data_5yrs_total$first_yr<-ifelse(grepl("old",as.character(data_5yrs_total$id)),1987,2006)

data.stack10$year <- c(data_5yrs_total$first_yr,
                     data_5yrs$year)

# Temperature column is only relevant for FFD, but is set to 0 for fitness values
data.stack10$temp <- c(rep(0, 163), data_5yrs$cmean_4)

# Create single column with first fitness values (ABSOLUTE VALUES), then FFD values:
data.stack10$fitness.FFD.stack <- c(round(data_5yrs_total$mean_fitness_life), data_5yrs$FFD)

# Create 3 index columns needed for MCMCglmm
data.stack10$traits <- c(rep("fitness", 163), rep("FFD", 1162))
data.stack10$variable <- data.stack10$traits
# Fitness will be modelled with an overdispersed Poisson 
# FFD will be modelled with a Gaussian distribution
# Specify this with the column 'family':
data.stack10$family <- c(rep("poisson", 163), rep("gaussian", 1162))
data.stack10 <- data.frame(data.stack10)

data.stack10$id <- as.factor(data.stack10$id)
data.stack10$year <- as.factor(data.stack10$year)
head(data.stack10)
```

```{r sc and prior}
# Scaling factor for MCMCglmm iterations
sc <- 1000 # Increase this parameter for longer runs

priorBiv_RR10 <- list(G = list(G1 = list(V = diag(1), nu = 1)),
                    # ^ random effect for year (fitted for FFD only)
                    R = list(R1 = list(V = diag(3), nu = 3, covu = TRUE), 
                             # ^ 3-way var-cov matrix of (id + temp:id) for FFD,
                             # residual for fitness
                             R2 = list(V = diag(1), nu = 1))) # residual for FFD
```


```{r MCMCglmm models 1, eval=FALSE, include=TRUE}
modelBV_RR10 <- MCMCglmm(fitness.FFD.stack ~ variable - 1 + 
                         # ^ means for each variable (and no overall mean (hence "-1"))
                         at.level(variable, "FFD"):temp,  # single fixed effect of temp 
                         random = ~us(at.level(variable, "FFD")):year +
                           us(at.level(variable, "FFD") + 
                                at.level(variable,"FFD"):temp):id,
                       # ^ random intercepts for individual, 
                       # and random slopes for temp|id
                       rcov = ~us(at.level(variable, "fitness")):id + 
                         # ^ variance between indivdiuals in fitness
                         # (which is residual variance)
                         us(at.level(variable, "FFD")):Obs,    
                         # ^ residual variance within indivdiuals between years 
                       # (labelled by 'Obs')
                       data = data.stack10,
                       prior = priorBiv_RR10, 
                       family = NULL, # specified already in the data-set
                       nitt = 2100 * sc, thin = sc, burnin = 100 * sc, 
                       verbose = F,singular.ok = T) 
# nitt = burnin + thin*(n samples to keep)
# Aim to store 2000 iterations
save(modelBV_RR10,file="C:/Users/User/Dropbox/SU/Projects/lathyrus/lathyrus_ms2/code/objects/modelBV_RR10.RData")
```

```{r MCMCglmm models 2}
kable(summary(modelBV_RR10)$solutions,digits=c(3,3,3,0,3),caption="Fixed effects") 
```

```{r MCMCglmm models 3}
kable(summary(modelBV_RR10)$Gcovariances,digits=c(3,3,3,0),caption="Random effects")
```

```{r MCMCglmm models 4}
kable(summary(modelBV_RR10)$Rcovariances,digits=c(3,3,3,0),caption="Random effects")
```

```{r MCMCglmm models 5}
kable(diag(autocorr(modelBV_RR10$Sol)[2, , ]),caption="Autocorrelation")
kable(diag(autocorr(modelBV_RR10$VCV)[2, , ]),caption="Autocorrelation")
```

For interpretation of covariances, we convert them to correlations using the formula for a correlation with the posterior distributions of our (co)variance components. This gives us a distribution of correlation values that we can use to calculate estimates and 95% credible intervals (code adapted from Houslay & Wilson 2017 Behav. Ecol.).

Among-individual correlation between intercepts and slopes for FFD:

```{r MCMCglmm models 6, fig.height=2.5, fig.width=6}
cor_BV_RR_10_intslope <- 
  modelBV_RR10$VCV[,"at.level(variable, \"FFD\"):temp.id:at.level(variable, \"FFD\").id"]/
(sqrt(modelBV_RR10$VCV[,"at.level(variable, \"FFD\").id:at.level(variable, \"FFD\").id"])*
sqrt(modelBV_RR10$VCV[,"at.level(variable, \"FFD\"):temp.id:at.level(variable, \"FFD\"):temp.id"]))
plot(cor_BV_RR_10_intslope)
posterior.mode(cor_BV_RR_10_intslope)
HPDinterval(cor_BV_RR_10_intslope) 
```

Among-individual correlation between FFD and fitness: 

```{r MCMCglmm models 7, fig.height=2.5, fig.width=6}
cor_BV_RR_10_intfit <-
  modelBV_RR10$VCV[,"at.level(variable, \"fitness\").id:at.level(variable, \"FFD\").id"]/
  (sqrt(modelBV_RR10$VCV[,"at.level(variable, \"fitness\").id:at.level(variable, \"fitness\").id"])*
     sqrt(modelBV_RR10$VCV[,"at.level(variable, \"FFD\").id:at.level(variable, \"FFD\").id"]))
plot(cor_BV_RR_10_intfit)
posterior.mode(cor_BV_RR_10_intfit)
HPDinterval(cor_BV_RR_10_intfit)
```

Among-individual correlation between fitness and variation in slopes for FFD: 

```{r MCMCglmm models 8, fig.height=2.5, fig.width=6}
cor_BV_RR_10_slopefit <- 
  modelBV_RR10$VCV[,"at.level(variable, \"fitness\").id:at.level(variable, \"FFD\"):temp.id"]/
  (sqrt(modelBV_RR10$VCV[,"at.level(variable, \"fitness\").id:at.level(variable, \"fitness\").id"])*
     sqrt(modelBV_RR10$VCV[,"at.level(variable, \"FFD\"):temp.id:at.level(variable, \"FFD\"):temp.id"]))
plot(cor_BV_RR_10_slopefit)
posterior.mode(cor_BV_RR_10_slopefit)
HPDinterval(cor_BV_RR_10_slopefit)
```

Intercepts and slopes of RNs are positively correlated: Plants that flower earlier on average are also more responsive to temperature. Fitness is negatively correlated with both the intercept and the slope of the RN: individuals that flower earlier on average and are more responsive to temperature have higher fitness. 

#### Extract selection coefficients

Selection differentials or gradients should be calculated using relative fitness, and models are typically fitted assuming Gaussian errors. However, where the fitness measure follows a non-Gaussian distribution, as is typically the case with skewed distributions of fitness, a GLMM of absolute fitness will be preferable. The resulting covariances returned by the model will then be between the trait on the data scale and fitness on a ‘latent’ (link-function) scale. These estimates need to be transformed if data-scale estimates of selection are required. However, in the case of a GLMM with a log-link function (e.g. Poisson here), it is possible to exploit the fact that the latent-scale covariance with absolute fitness is equivalent to the data-scale covariance of relative fitness: consequently, and conveniently, the covariance components of the var-covar matrix on the latent scale can simply be treated as selection differentials S. By extension, estimates of selection gradients will also provide data-scale selection gradients.

```{r selcoefs 1, fig.height=2.5, fig.width=6}
# Extract 3x3 matrix of variance-covariance values for intercepts and slopes 
# of temp, and fitness 
# These are in the 2nd-10th columns of model output
P.modelBV_RR10 <- modelBV_RR10$VCV[,2:10]         
P.modelBV_RR10.mode <- matrix(1:9, nrow = 3)
for (k in 1:9) P.modelBV_RR10.mode[k] <- posterior.mode(P.modelBV_RR10[,k])
P.modelBV_RR10.mode

# Extract selection *differentials* (i.e. covariances) for intercept and slope:
# and calculate posterior mode and credible intervals for each
S.modelBV_RR10 <- modelBV_RR10$VCV[, c(4,7)]
S.modelBV_RR10 <- P.modelBV_RR10[, c(3,6)] # This is exactly the same as above
colnames(S.modelBV_RR10) <- c("S_intercepts", "S_slopes")
S.modelBV_RR10.mode <- P.modelBV_RR10.mode[1:2, 3]
S.modelBV_RR10.mode
posterior.mode(mcmc(S.modelBV_RR10)) # This is exactly the same as above
HPDinterval(mcmc(S.modelBV_RR10))

# Plot posterior distribution of selection differentials
par(mfrow = c(1,2))
plot(density(S.modelBV_RR10[,1]), main = "S_intercepts")
plot(density(S.modelBV_RR10[,2]), main = "S_slopes")

# Estimate selection gradients for intercept and slope (beta = S / P)
# on each sample of posterior and extract their mode
n <- length(modelBV_RR10$VCV[,2])   # sample size
beta_post_RR10 <- matrix(NA, n ,2)

for (i in 1:n) {
  P3 <- matrix(rep(NA, 9), nrow = 3)  
  # 3x3 matrix of var-cov for individual X.int, X.slope and fitness
  for (k in 1:9) {P3[k] <- P.modelBV_RR10[i, k] }  
  P2 <- P3[1:2, 1:2]   # 2x2 matrix of just trait intercept & slope var-cov
  S <- P3[1:2, 3]   # selection differentials on traits (last column of P3)
  beta_post_RR10[i,] <- solve(P2) %*% S   # selection gradients beta = P^-1 * S
}

# Finally, extract and plot the selection gradients posterior modes 
# and 95% credible intervals for both selection on intercepts (trait value) 
# and slopes (trait plasticity).

colnames(beta_post_RR10) <- c("beta_intercepts", "beta_slopes")
posterior.mode(mcmc(beta_post_RR10))
HPDinterval(mcmc(beta_post_RR10))

# Plot posterior distribution of selection gradients
par(mfrow = c(1,2))
plot(density(beta_post_RR10[,1]), main = "beta_intercepts")
plot(density(beta_post_RR10[,2]), main = "beta_slopes")
```

The selection differentials are "significant" for both RN intercepts and slopes, and the selection gradient is only significant for the RN intercept (althought the interval almost includes zero). This means that, there is significant total selection (direct + indirect) on intercepts and slopes, but after correcting for the covariance between them, there is direct selection only on the intercept of the RN (i.e. on the average flowering time). Can we say this with the intervals being so close to including zero?

### With shoot volume

Stack data:

```{r stack data 3}
# Create a single data-set "data.stack14", with single column at start
# to index observations
data.stack14 <- c()
data.stack14$Obs <- 1:(163 + 1162)
data.stack14$id <- c(as.character(data_5yrs_total$id),as.character(data_5yrs$id)) 
# ids in alphabetical order

# Year column is only relevant for FFD, but is set to first_yr for fitness values
data.stack14$year <- c(data_5yrs_total$first_yr,
                     data_5yrs$year)
# Temperature column is only relevant for FFD, but is set to 0 for fitness values
data.stack14$temp <- c(rep(0, 163), data_5yrs$cmean_4)

# Shoot volume column is only relevant for fitness, but is set to 0 for FFD values
# Using sqrt of mean shoot volume over all years when available, centered
data_5yrs_total<-data_5yrs_total%>%
  mutate(shoot_vol_mean_sqrt=sqrt(shoot_vol_mean),
         cn_shoot_vol_mean_sqrt=scale(shoot_vol_mean_sqrt,center=T,scale=F))
data.stack14$cn_shoot_vol <- c(data_5yrs_total$cn_shoot_vol_mean_sqrt,rep(0, 1162))

# Create single column with first fitness values (ABSOLUTE VALUES), then FFD values:
data.stack14$fitness.FFD.stack <- c(round(data_5yrs_total$mean_fitness_life), data_5yrs$FFD)

# Create 3 index columns needed for MCMCglmm
data.stack14$traits <- c(rep("fitness", 163), rep("FFD", 1162))
data.stack14$variable <- data.stack14$traits
# Fitness will be modelled with an overdispersed Poisson 
# FFD will be modelled with a Gaussian distribution
# Specify this with the column 'family':
data.stack14$family <- c(rep("poisson", 163), rep("gaussian", 1162))
data.stack14 <- data.frame(data.stack14)

data.stack14$id <- as.factor(data.stack14$id)
data.stack14$year <- as.factor(data.stack14$year)
head(data.stack14)
```

```{r MCMCglmm models 17, eval=FALSE, include=TRUE}
modelBV_RR14 <- MCMCglmm(fitness.FFD.stack ~ variable - 1 + 
                         # ^ means for each variable (and no overall mean (hence "-1"))
                         at.level(variable, "FFD"):temp +  # single fixed effect of temp 
                           at.level(variable,"fitness"):cn_shoot_vol, 
                         random = ~us(at.level(variable, "FFD")):year +
                           us(at.level(variable, "FFD") + 
                                at.level(variable,"FFD"):temp):id,
                       # ^ random intercepts for individual, 
                       # and random slopes for temp|id
                       rcov = ~us(at.level(variable, "fitness")):id + 
                         # ^ variance between indivdiuals in fitness
                         # (which is residual variance)
                         us(at.level(variable, "FFD")):Obs,    
                         # ^ residual variance within indivdiuals between years 
                       # (labelled by 'Obs')
                       data = data.stack14,
                       prior = priorBiv_RR10, 
                       family = NULL, # specified already in the data-set
                       nitt = 2100 * sc, thin = sc, burnin = 100 * sc, 
                       verbose = F,singular.ok = T)
save(modelBV_RR14,file="C:/Users/User/Dropbox/SU/Projects/lathyrus/lathyrus_ms2/code/objects/modelBV_RR14.RData")
```

```{r MCMCglmm models 18}
kable(summary(modelBV_RR14)$solutions,digits=c(3,3,3,0,3),caption="Fixed effects") 
```

```{r MCMCglmm models 19}
kable(summary(modelBV_RR14)$Gcovariances,digits=c(3,3,3,0),caption="Random effects")
```

```{r MCMCglmm models 20}
kable(summary(modelBV_RR14)$Rcovariances,digits=c(3,3,3,0),caption="Random effects")
```

```{r MCMCglmm models 21}
kable(diag(autocorr(modelBV_RR14$Sol)[2, , ]),caption="Autocorrelation")
kable(diag(autocorr(modelBV_RR14$VCV)[2, , ]),caption="Autocorrelation")
```

Among-individual correlation between intercepts and slopes for FFD:

```{r MCMCglmm models 22, fig.height=2.5, fig.width=6}
cor_BV_RR_14_intslope <- 
  modelBV_RR14$VCV[,"at.level(variable, \"FFD\"):temp.id:at.level(variable, \"FFD\").id"]/
(sqrt(modelBV_RR14$VCV[,"at.level(variable, \"FFD\").id:at.level(variable, \"FFD\").id"])*
sqrt(modelBV_RR14$VCV[,"at.level(variable, \"FFD\"):temp.id:at.level(variable, \"FFD\"):temp.id"]))
plot(cor_BV_RR_14_intslope)
posterior.mode(cor_BV_RR_14_intslope)
HPDinterval(cor_BV_RR_14_intslope) 
```

Among-individual correlation between FFD and fitness: 

```{r MCMCglmm models 23, fig.height=2.5, fig.width=6}
cor_BV_RR_14_intfit <-
  modelBV_RR14$VCV[,"at.level(variable, \"fitness\").id:at.level(variable, \"FFD\").id"]/
  (sqrt(modelBV_RR14$VCV[,"at.level(variable, \"fitness\").id:at.level(variable, \"fitness\").id"])*
     sqrt(modelBV_RR14$VCV[,"at.level(variable, \"FFD\").id:at.level(variable, \"FFD\").id"]))
plot(cor_BV_RR_14_intfit)
posterior.mode(cor_BV_RR_14_intfit)
HPDinterval(cor_BV_RR_14_intfit)
```

Among-individual correlation between fitness and variation in slopes for FFD: 

```{r MCMCglmm models 24, fig.height=2.5, fig.width=6}
cor_BV_RR_14_slopefit <- 
  modelBV_RR14$VCV[,"at.level(variable, \"fitness\").id:at.level(variable, \"FFD\"):temp.id"]/
  (sqrt(modelBV_RR14$VCV[,"at.level(variable, \"fitness\").id:at.level(variable, \"fitness\").id"])*
     sqrt(modelBV_RR14$VCV[,"at.level(variable, \"FFD\"):temp.id:at.level(variable, \"FFD\"):temp.id"]))
plot(cor_BV_RR_14_slopefit)
posterior.mode(cor_BV_RR_14_slopefit)
HPDinterval(cor_BV_RR_14_slopefit)
```

Intercepts and slopes of RNs are positively correlated: Plants that flower earlier on average are also more responsive to temperature. Fitness is not correlated with either the intercept or the slope of the RN: There is no selection on either the intercept or the slope of the RN when including plant size as a condition variable. 

#### Extract selection coefficients

```{r selcoefs 3, fig.height=2.5, fig.width=6}
P.modelBV_RR14 <- modelBV_RR14$VCV[,2:10]         
P.modelBV_RR14.mode <- matrix(1:9, nrow = 3)
for (k in 1:9) P.modelBV_RR14.mode[k] <- posterior.mode(P.modelBV_RR14[,k])
P.modelBV_RR14.mode

S.modelBV_RR14 <- modelBV_RR14$VCV[, c(4,7)]
S.modelBV_RR14 <- P.modelBV_RR14[, c(3,6)]
colnames(S.modelBV_RR14) <- c("S_intercepts", "S_slopes")
S.modelBV_RR14.mode <- P.modelBV_RR14.mode[1:2, 3]
S.modelBV_RR14.mode
posterior.mode(mcmc(S.modelBV_RR14))
HPDinterval(mcmc(S.modelBV_RR14))

par(mfrow = c(1,2))
plot(density(S.modelBV_RR14[,1]), main = "S_intercepts")
plot(density(S.modelBV_RR14[,2]), main = "S_slopes")

n <- length(modelBV_RR14$VCV[,2])   # sample size
beta_post_RR14 <- matrix(NA, n ,2)

for (i in 1:n) {
  P3 <- matrix(rep(NA, 9), nrow = 3)  
  # 3x3 matrix of var-cov for individual X.int, X.slope and fitness
  for (k in 1:9) {P3[k] <- P.modelBV_RR14[i, k] }  
  P2 <- P3[1:2, 1:2]   # 2x2 matrix of just trait intercept & slope var-cov
  S <- P3[1:2, 3]   # selection differentials on traits (last column of P3)
  beta_post_RR14[i,] <- solve(P2) %*% S   # selection gradients beta = P^-1 * S
}

colnames(beta_post_RR14) <- c("beta_intercepts", "beta_slopes")
posterior.mode(mcmc(beta_post_RR14))
HPDinterval(mcmc(beta_post_RR14))

par(mfrow = c(1,2))
plot(density(beta_post_RR14[,1]), main = "beta_intercepts")
plot(density(beta_post_RR14[,2]), main = "beta_slopes")
```

The selection differentials and gradients are not "significant" for either RN intercepts or slopes. This means that there is no significant selection (either direct or indirect) on intercepts and slopes of the RNs.

## Mean fitness per flowering event

### With no condition variable

Stack data:

```{r stack data 4}
# Create a single data-set "data.stack12", with single column at start 
# to index observations
data.stack12 <- c()
data.stack12$Obs <- 1:(163 + 1162)
data.stack12$id <- c(as.character(data_5yrs_total$id),as.character(data_5yrs$id)) 
# ids in alphabetical order

# Year column is only relevant for FFD, but is set to first_yr for fitness values
data.stack12$year <- c(data_5yrs_total$first_yr,
                     data_5yrs$year)
# Temperature column is only relevant for FFD, but is set to 0 for fitness values
data.stack12$temp <- c(rep(0, 163), data_5yrs$cmean_4)

# Create single column with first fitness values (ABSOLUTE VALUES), then FFD values:
data.stack12$fitness.FFD.stack <- c(round(data_5yrs_total$mean_fitness_fl), data_5yrs$FFD)

# Create 3 index columns needed for MCMCglmm
data.stack12$traits <- c(rep("fitness", 163), rep("FFD", 1162))
data.stack12$variable <- data.stack12$traits
# Fitness will be modelled with an overdispersed Poisson 
# FFD will be modelled with a Gaussian distribution
# Specify this with the column 'family':
data.stack12$family <- c(rep("poisson", 163), rep("gaussian", 1162))
data.stack12 <- data.frame(data.stack12)

data.stack12$id <- as.factor(data.stack12$id)
data.stack12$year <- as.factor(data.stack12$year)
head(data.stack12)
```

```{r MCMCglmm models 25, eval=FALSE, include=TRUE}
modelBV_RR12 <- MCMCglmm(fitness.FFD.stack ~ variable - 1 + 
                         # ^ means for each variable (and no overall mean (hence "-1"))
                         at.level(variable, "FFD"):temp,  # single fixed effect of temp 
                         random = ~us(at.level(variable, "FFD")):year +
                           us(at.level(variable, "FFD") + 
                                at.level(variable,"FFD"):temp):id,
                       # ^ random intercepts for individual, 
                       # and random slopes for temp|id
                       rcov = ~us(at.level(variable, "fitness")):id + 
                         # ^ variance between indivdiuals in fitness
                         # (which is residual variance)
                         us(at.level(variable, "FFD")):Obs,    
                         # ^ residual variance within indivdiuals between years 
                       # (labelled by 'Obs')
                       data = data.stack12,
                       prior = priorBiv_RR10, 
                       family = NULL, # specified already in the data-set
                       nitt = 2100 * sc, thin = sc, burnin = 100 * sc, 
                       verbose = F,singular.ok = T)
save(modelBV_RR12,file="C:/Users/User/Dropbox/SU/Projects/lathyrus/lathyrus_ms2/code/objects/modelBV_RR12.RData")
```

```{r MCMCglmm models 26}
kable(summary(modelBV_RR12)$solutions,digits=c(3,3,3,0,3),caption="Fixed effects") 
```

```{r MCMCglmm models 27}
kable(summary(modelBV_RR12)$Gcovariances,digits=c(3,3,3,0),caption="Random effects")
```

```{r MCMCglmm models 28}
kable(summary(modelBV_RR12)$Rcovariances,digits=c(3,3,3,0),caption="Random effects")
```

```{r MCMCglmm models 29}
kable(diag(autocorr(modelBV_RR12$Sol)[2, , ]),caption="Autocorrelation")
kable(diag(autocorr(modelBV_RR12$VCV)[2, , ]),caption="Autocorrelation")
```

Among-individual correlation between intercepts and slopes for FFD:

```{r MCMCglmm models 30, fig.height=2.5, fig.width=6}
cor_BV_RR_12_intslope <- 
  modelBV_RR12$VCV[,"at.level(variable, \"FFD\"):temp.id:at.level(variable, \"FFD\").id"]/
(sqrt(modelBV_RR12$VCV[,"at.level(variable, \"FFD\").id:at.level(variable, \"FFD\").id"])*
sqrt(modelBV_RR12$VCV[,"at.level(variable, \"FFD\"):temp.id:at.level(variable, \"FFD\"):temp.id"]))
plot(cor_BV_RR_12_intslope)
posterior.mode(cor_BV_RR_12_intslope)
HPDinterval(cor_BV_RR_12_intslope) 
```

Among-individual correlation between FFD and fitness: 

```{r MCMCglmm models 32, fig.height=2.5, fig.width=6}
cor_BV_RR_12_intfit <-
  modelBV_RR12$VCV[,"at.level(variable, \"fitness\").id:at.level(variable, \"FFD\").id"]/
  (sqrt(modelBV_RR12$VCV[,"at.level(variable, \"fitness\").id:at.level(variable, \"fitness\").id"])*
     sqrt(modelBV_RR12$VCV[,"at.level(variable, \"FFD\").id:at.level(variable, \"FFD\").id"]))
plot(cor_BV_RR_12_intfit)
posterior.mode(cor_BV_RR_12_intfit)
HPDinterval(cor_BV_RR_12_intfit)
```

Among-individual correlation between fitness and variation in slopes for FFD: 

```{r MCMCglmm models 33, fig.height=2.5, fig.width=6}
cor_BV_RR_12_slopefit <- 
  modelBV_RR12$VCV[,"at.level(variable, \"fitness\").id:at.level(variable, \"FFD\"):temp.id"]/
  (sqrt(modelBV_RR12$VCV[,"at.level(variable, \"fitness\").id:at.level(variable, \"fitness\").id"])*
     sqrt(modelBV_RR12$VCV[,"at.level(variable, \"FFD\"):temp.id:at.level(variable, \"FFD\"):temp.id"]))
plot(cor_BV_RR_12_slopefit)
posterior.mode(cor_BV_RR_12_slopefit)
HPDinterval(cor_BV_RR_12_slopefit)
```

Intercepts and slopes of RNs are positively correlated: Plants that flower earlier on average are also more responsive to temperature. Fitness is negatively correlated with both the intercept and the slope of the RN: individuals that flower earlier on average and are more responsive to temperature have higher fitness. 

#### Extract selection coefficients

```{r selcoefs 4, fig.height=2.5, fig.width=6}
P.modelBV_RR12 <- modelBV_RR12$VCV[,2:10]         
P.modelBV_RR12.mode <- matrix(1:9, nrow = 3)
for (k in 1:9) P.modelBV_RR12.mode[k] <- posterior.mode(P.modelBV_RR12[,k])
P.modelBV_RR12.mode

S.modelBV_RR12 <- modelBV_RR12$VCV[, c(4,7)]
S.modelBV_RR12 <- P.modelBV_RR12[, c(3,6)]
colnames(S.modelBV_RR12) <- c("S_intercepts", "S_slopes")
S.modelBV_RR12.mode <- P.modelBV_RR12.mode[1:2, 3]
S.modelBV_RR12.mode
posterior.mode(mcmc(S.modelBV_RR12))
HPDinterval(mcmc(S.modelBV_RR12))

par(mfrow = c(1,2))
plot(density(S.modelBV_RR12[,1]), main = "S_intercepts")
plot(density(S.modelBV_RR12[,2]), main = "S_slopes")

n <- length(modelBV_RR12$VCV[,2])   # sample size
beta_post_RR12 <- matrix(NA, n ,2)

for (i in 1:n) {
  P3 <- matrix(rep(NA, 9), nrow = 3)  
  # 3x3 matrix of var-cov for individual X.int, X.slope and fitness
  for (k in 1:9) {P3[k] <- P.modelBV_RR12[i, k] }  
  P2 <- P3[1:2, 1:2]   # 2x2 matrix of just trait intercept & slope var-cov
  S <- P3[1:2, 3]   # selection differentials on traits (last column of P3)
  beta_post_RR12[i,] <- solve(P2) %*% S   # selection gradients beta = P^-1 * S
}

colnames(beta_post_RR12) <- c("beta_intercepts", "beta_slopes")
posterior.mode(mcmc(beta_post_RR12))
HPDinterval(mcmc(beta_post_RR12))

par(mfrow = c(1,2))
plot(density(beta_post_RR12[,1]), main = "beta_intercepts")
plot(density(beta_post_RR12[,2]), main = "beta_slopes")
```

The selection differential is "significant" for RN intercepts but not for RN slopes. The selection gradients are not "significant" for any of them. This means that, there is significant total selection (direct + indirect) on intercepts of the RN, but after correcting for the covariance with slopes, there is no direct selection on any of them. There is no significant selection (either direct or indirect) on slopes of the RNs.

### With shoot volume

Stack data:

```{r stack data 6}
# Create a single data-set "data.stack15", with single column at start 
# to index observations
data.stack15 <- c()
data.stack15$Obs <- 1:(163 + 1162)
data.stack15$id <- c(as.character(data_5yrs_total$id),as.character(data_5yrs$id)) 
# ids in alphabetical order

# Year column is only relevant for FFD, but is set to first_yr for fitness values

data.stack15$year <- c(data_5yrs_total$first_yr,
                     data_5yrs$year)
# Temperature column is only relevant for FFD, but is set to 0 for fitness values
data.stack15$temp <- c(rep(0, 163), data_5yrs$cmean_4)

# Shoot volume column is only relevant for fitness, but is set to 0 for FFD values
# Using sqrt of mean shoot volume over all years when available, centered
data.stack15$cn_shoot_vol <- c(data_5yrs_total$cn_shoot_vol_mean_sqrt,rep(0, 1162))

# Create single column with first fitness values (ABSOLUTE VALUES), then FFD values:
data.stack15$fitness.FFD.stack <- c(round(data_5yrs_total$mean_fitness_fl), data_5yrs$FFD)

# Create 3 index columns needed for MCMCglmm
data.stack15$traits <- c(rep("fitness", 163), rep("FFD", 1162))
data.stack15$variable <- data.stack15$traits
# Fitness will be modelled with an overdispersed Poisson 
# FFD will be modelled with a Gaussian distribution
# Specify this with the column 'family':
data.stack15$family <- c(rep("poisson", 163), rep("gaussian", 1162))
data.stack15 <- data.frame(data.stack15)

data.stack15$id <- as.factor(data.stack15$id)
data.stack15$year <- as.factor(data.stack15$year)
head(data.stack15)
```

```{r MCMCglmm models 42, eval=FALSE, include=TRUE}
modelBV_RR15 <- MCMCglmm(fitness.FFD.stack ~ variable - 1 + 
                         # ^ means for each variable (and no overall mean (hence "-1"))
                         at.level(variable, "FFD"):temp +  # single fixed effect of temp 
                           at.level(variable,"fitness"):cn_shoot_vol, 
                         random = ~us(at.level(variable, "FFD")):year +
                           us(at.level(variable, "FFD") + 
                                at.level(variable,"FFD"):temp):id,
                       # ^ random intercepts for individual, 
                       # and random slopes for temp|id
                       rcov = ~us(at.level(variable, "fitness")):id + 
                         # ^ variance between indivdiuals in fitness
                         # (which is residual variance)
                         us(at.level(variable, "FFD")):Obs,    
                         # ^ residual variance within indivdiuals between years 
                       # (labelled by 'Obs')
                       data = data.stack15,
                       prior = priorBiv_RR10, 
                       family = NULL, # specified already in the data-set
                       nitt = 2100 * sc, thin = sc, burnin = 100 * sc, 
                       verbose = F,singular.ok = T)
save(modelBV_RR15,file="C:/Users/User/Dropbox/SU/Projects/lathyrus/lathyrus_ms2/code/objects/modelBV_RR15.RData")
```

```{r MCMCglmm models 43}
kable(summary(modelBV_RR15)$solutions,digits=c(3,3,3,0,3),caption="Fixed effects") 
```

```{r MCMCglmm models 44}
kable(summary(modelBV_RR15)$Gcovariances,digits=c(3,3,3,0),caption="Random effects")
```

```{r MCMCglmm models 45}
kable(summary(modelBV_RR15)$Rcovariances,digits=c(3,3,3,0),caption="Random effects")
```

```{r MCMCglmm models 46}
kable(diag(autocorr(modelBV_RR15$Sol)[2, , ]),caption="Autocorrelation")
kable(diag(autocorr(modelBV_RR15$VCV)[2, , ]),caption="Autocorrelation")
```

Among-individual correlation between intercepts and slopes for FFD:

```{r MCMCglmm models 47, fig.height=2.5, fig.width=6}
cor_BV_RR_15_intslope <- 
  modelBV_RR15$VCV[,"at.level(variable, \"FFD\"):temp.id:at.level(variable, \"FFD\").id"]/
(sqrt(modelBV_RR15$VCV[,"at.level(variable, \"FFD\").id:at.level(variable, \"FFD\").id"])*
sqrt(modelBV_RR15$VCV[,"at.level(variable, \"FFD\"):temp.id:at.level(variable, \"FFD\"):temp.id"]))
plot(cor_BV_RR_15_intslope)
posterior.mode(cor_BV_RR_15_intslope)
HPDinterval(cor_BV_RR_15_intslope) 
```

Among-individual correlation between FFD and fitness: 

```{r MCMCglmm models 48, fig.height=2.5, fig.width=6}
cor_BV_RR_15_intfit <-
  modelBV_RR15$VCV[,"at.level(variable, \"fitness\").id:at.level(variable, \"FFD\").id"]/
  (sqrt(modelBV_RR15$VCV[,"at.level(variable, \"fitness\").id:at.level(variable, \"fitness\").id"])*
     sqrt(modelBV_RR15$VCV[,"at.level(variable, \"FFD\").id:at.level(variable, \"FFD\").id"]))
plot(cor_BV_RR_15_intfit)
posterior.mode(cor_BV_RR_15_intfit)
HPDinterval(cor_BV_RR_15_intfit)
```

Among-individual correlation between fitness and variation in slopes for FFD: 

```{r MCMCglmm models 49, fig.height=2.5, fig.width=6}
cor_BV_RR_15_slopefit <- 
  modelBV_RR15$VCV[,"at.level(variable, \"fitness\").id:at.level(variable, \"FFD\"):temp.id"]/
  (sqrt(modelBV_RR15$VCV[,"at.level(variable, \"fitness\").id:at.level(variable, \"fitness\").id"])*
     sqrt(modelBV_RR15$VCV[,"at.level(variable, \"FFD\"):temp.id:at.level(variable, \"FFD\"):temp.id"]))
plot(cor_BV_RR_15_slopefit)
posterior.mode(cor_BV_RR_15_slopefit)
HPDinterval(cor_BV_RR_15_slopefit)
```

Intercepts and slopes of RNs are positively correlated: Plants that flower earlier on average are also more responsive to temperature. Fitness is correlated with the intercept but not with the slope of the RN: Individuals that flower earlier on average have higher fitness but there is not selection on the slope. 

#### Extract selection coefficients

```{r selcoefs 6, fig.height=2.5, fig.width=6}
P.modelBV_RR15 <- modelBV_RR15$VCV[,2:10]         
P.modelBV_RR15.mode <- matrix(1:9, nrow = 3)
for (k in 1:9) P.modelBV_RR15.mode[k] <- posterior.mode(P.modelBV_RR15[,k])
P.modelBV_RR15.mode

S.modelBV_RR15 <- modelBV_RR15$VCV[, c(4,7)]
S.modelBV_RR15 <- P.modelBV_RR15[, c(3,6)]
colnames(S.modelBV_RR15) <- c("S_intercepts", "S_slopes")
S.modelBV_RR15.mode <- P.modelBV_RR15.mode[1:2, 3]
S.modelBV_RR15.mode
posterior.mode(mcmc(S.modelBV_RR15))
HPDinterval(mcmc(S.modelBV_RR15))

par(mfrow = c(1,2))
plot(density(S.modelBV_RR15[,1]), main = "S_intercepts")
plot(density(S.modelBV_RR15[,2]), main = "S_slopes")

n <- length(modelBV_RR15$VCV[,2])   # sample size
beta_post_RR15 <- matrix(NA, n ,2)

for (i in 1:n) {
  P3 <- matrix(rep(NA, 9), nrow = 3)  
  # 3x3 matrix of var-cov for individual X.int, X.slope and fitness
  for (k in 1:9) {P3[k] <- P.modelBV_RR15[i, k] }  
  P2 <- P3[1:2, 1:2]   # 2x2 matrix of just trait intercept & slope var-cov
  S <- P3[1:2, 3]   # selection differentials on traits (last column of P3)
  beta_post_RR15[i,] <- solve(P2) %*% S   # selection gradients beta = P^-1 * S
}

colnames(beta_post_RR15) <- c("beta_intercepts", "beta_slopes")
posterior.mode(mcmc(beta_post_RR15))
HPDinterval(mcmc(beta_post_RR15))

par(mfrow = c(1,2))
plot(density(beta_post_RR15[,1]), main = "beta_intercepts")
plot(density(beta_post_RR15[,2]), main = "beta_slopes")
```

The selection differentials and gradients are not "significant" for either RN intercepts or slopes. This means that there is no significant selection (either direct or indirect) on intercepts and slopes of the RNs.

# Correlation among size and RN parameters

There is no selection on RN parameters when including plant size as a condition variable. Selection on plasticity might be mediated by the resource state of the plants - this might be indicated by a correlation among plant size and the parameters of the RN. We check this by looking at correlations among plant size (shoot volume) and the BLUPs for intercept and slope of the RN (NOTE: this is maybe not a good use of BLUPs because they do not have associated measures of uncertainty!).

```{r cor size RN pars 1, message=FALSE, warning=FALSE}
BLUPs_MCMC<-BLUPs_MCMC%>%
  right_join(shoot_vol_means)

with(BLUPs_MCMC,cor.test(shoot_vol_mean,intercept))  # -0.3685886*
summary(lm(intercept~shoot_vol_mean,BLUPs_MCMC))
summary(lm(intercept~log(shoot_vol_mean),BLUPs_MCMC))
summary(lm(intercept~sqrt(shoot_vol_mean),BLUPs_MCMC))

with(BLUPs_MCMC,cor.test(shoot_vol_mean,slope))  # -0.3762481*
summary(lm(slope~shoot_vol_mean,BLUPs_MCMC))
summary(lm(slope~log(shoot_vol_mean),BLUPs_MCMC))
summary(lm(slope~sqrt(shoot_vol_mean),BLUPs_MCMC))
```

```{r cor size RN pars 2, echo=FALSE, fig.height=4, fig.width=9, message=FALSE, warning=FALSE}
grid.arrange(
  ggplot(BLUPs_MCMC,aes(sqrt(shoot_vol_mean),intercept))+
    geom_point()+geom_smooth(method="lm")+my_theme(),
  ggplot(BLUPs_MCMC,aes(sqrt(shoot_vol_mean),slope))+
    geom_point()+geom_smooth(method="lm")+my_theme(),
  ncol=2)
```

There is a significant negative correlation among size and RN elevation and slope, meaning that larger plants have lower elevations (i.e. flower earlier on average) and slopes (i.e. are more responsive to temperature).

Some graphs for BLUPs showing the size of individuals:

```{r BLUPs_all23, echo=FALSE, fig.height=4, fig.width=10}
ggplot(BLUPs_MCMC, aes(id, intercept)) + 
  geom_point(aes(size = sqrt(shoot_vol_mean),colour = sqrt(shoot_vol_mean)),alpha = 0.6) + 
  ylab("BLUP intercept estimate") +
  geom_hline(yintercept = 0, lty = 2) + my_theme_legend() +
  theme(axis.text.x = element_blank()) +
  scale_size_continuous(range = c(1, 10))+
  scale_colour_gradientn(colours=rainbow(4))
```

```{r BLUPs_all24, echo=FALSE, fig.height=4, fig.width=10}
ggplot(BLUPs_MCMC, aes(id, slope)) + 
  geom_point(aes(size = sqrt(shoot_vol_mean),colour = sqrt(shoot_vol_mean)),alpha = 0.6) + 
  ylab("BLUP slope estimate") +
  geom_hline(yintercept = 0, lty = 2) + my_theme_legend() +
  theme(axis.text.x = element_blank()) +
  scale_size_continuous(range = c(1, 10))+
  scale_colour_gradientn(colours=rainbow(4))
```

```{r BLUPs_all25, echo=FALSE, fig.height=6, fig.width=10}
ggplot(BLUPs_MCMC, aes(intercept, slope)) +
  geom_point(aes(size = sqrt(shoot_vol_mean),colour = sqrt(shoot_vol_mean)), alpha = 0.4) +
    xlab("BLUP intercept estimate") + ylab("BLUP slope estimate") + my_theme_legend() +
  scale_size_continuous(range = c(1, 10))+ scale_colour_gradientn(colours=rainbow(4))
```

```{r BLUPs_all26, echo=FALSE, fig.height=4, fig.width=12}
BLUPs_MCMC<-BLUPs_MCMC%>%
  mutate(ranking = rank(slope))
ggplot(BLUPs_MCMC, aes(ranking, slope)) +
  geom_bar(stat = "identity", aes(fill = sqrt(shoot_vol_mean)))  +
  xlab("Id (in ranked order of plasticity)") +
  ylab("Plasticity (BLUP slope estimate)") +
  scale_fill_gradientn(colours=rainbow(4)) +
  my_theme_legend() + theme(axis.text.x = element_blank())
```

Plant size is significantly correlated with the BLUPs for elevation and slope: this might indicate that selection on RN parameters might be mediated by the resource state of the plants.

Plot of all the RNs coloured by size:

```{r BLUPs_all27, echo=FALSE, fig.height=12, fig.width=14, message=FALSE, warning=FALSE}
data_5yrs_shoot<-data_5yrs%>%
  right_join(data_5yrs_total[c(1,4)])
ggplot(data_5yrs_shoot,aes(x=cmean_4,y=FFD,group=id))+
  geom_smooth(method=lm,se=F,size=0.7,aes(colour = sqrt(shoot_vol_mean)))+
  xlab("Mean.centred mean daily temperature April")+
  ylab("First flowering date")+my_theme_legend() +
  scale_colour_gradientn(colours=rainbow(4))
```

# Variation in selection among years with BLUPs

Add BLUPs to data set

```{r}
data_5yrs<-data_5yrs%>%left_join(BLUPs_MCMC[1:3])
```

## Model with absolute fitness 

### glmmTMB

#### Year*(intercept+slope)

```{r}
model_years_abs<-glmmTMB(round(n_intact_seeds)~as.factor(year)*(intercept+slope)+(1|id),
                   data_5yrs,family=poisson) # Model is overdispersed
summary(model_years_abs)
Anova(model_years_abs)
```

#### Year*slope

Correlation intercept-slope is 0.94, so maybe not good to used them both in the same bebsamodel

```{r}
model_years_abs_slope<-glmmTMB(round(n_intact_seeds)~as.factor(year)*slope+(1|id),
                   data_5yrs,family=poisson) # Model is overdispersed
summary(model_years_abs_slope)
Anova(model_years_abs_slope)
```

#### Temp*(intercept+slope)

```{r}
model_years_abs_temp<-glmmTMB(round(n_intact_seeds)~cmean_4*(intercept+slope)+(1|id),
                   data_5yrs,family=poisson) # Model is overdispersed
summary(model_years_abs_temp)
Anova(model_years_abs_temp)
```

#### Temp*slope

```{r}
model_years_abs_temp_slope<-glmmTMB(round(n_intact_seeds)~cmean_4*slope+(1|id),
                   data_5yrs,family=poisson) # Model is overdispersed
summary(model_years_abs_temp_slope)
Anova(model_years_abs_temp_slope)
```

##### Plot

```{r message=FALSE, warning=FALSE}
myPalette <- colorRampPalette(brewer.pal(11, "YlOrRd"))
ggpredict(model_years_abs_temp_slope,
          terms = c("slope [all]", "cmean_4 [all]"))%>%
  ggplot(aes(x,predicted, ymin = conf.low, ymax = conf.high, colour = group, fill = group))+
  geom_line(aes(color=as.numeric(as.character(group)))) + 
  scale_colour_gradientn(colours = myPalette(100)) +
  # geom_ribbon(alpha = .1, colour = NA)+
  my_theme()+xlab("Slope")+ylab("Number of intact seeds")+
  theme(legend.position="right")+labs(colour="Temperature\nApril (mean-cent)")
```

#### Volume*slope

```{r}
model_years_abs_vol_slope<-glmmTMB(round(n_intact_seeds)~sqrt(shoot_vol)*slope+(1|id),
                   subset(data_5yrs,shoot_vol>0),family=poisson) # Model is overdispersed
summary(model_years_abs_vol_slope)
Anova(model_years_abs_vol_slope)
```

##### Plot

```{r message=FALSE, warning=FALSE}
ggpredict(model_years_abs_vol_slope,
          terms = c("slope [all]", "shoot_vol [10:150 by=25]"))%>%
  ggplot(aes(x,predicted, ymin = conf.low, ymax = conf.high, colour = group, fill = group))+
  geom_line(aes(color=as.numeric(as.character(group)))) + 
  scale_colour_gradientn(colours = myPalette(100)) +
  # geom_ribbon(alpha = .1, colour = NA)+
  my_theme()+xlab("Slope")+ylab("Number of intact seeds")+
  theme(legend.position="right")+labs(colour="Shoot volume")
```

#### Temp*slope+volume

```{r}
model_years_abs_temp_slope_vol<-glmmTMB(round(n_intact_seeds)~cmean_4*slope+sqrt(shoot_vol)+(1|id),
                   data_5yrs,family=poisson) # Model is overdispersed
summary(model_years_abs_temp_slope_vol)
Anova(model_years_abs_temp_slope_vol)
```

#### Temp*slope+volume*slope

```{r}
model_years_abs_temp_slope_vol_int<-glmmTMB(round(n_intact_seeds)~cmean_4*slope+
                                              sqrt(shoot_vol)*slope+(1|id),
                   data_5yrs,family=poisson) # Model is overdispersed
summary(model_years_abs_temp_slope_vol_int)
Anova(model_years_abs_temp_slope_vol_int)
```

### MCMCglmm -> USE

For both technical and philosophical reasons, MCMCglmm always adds an observation-level variance (referred to in MCMCglmm as the “R-structure”, for “residual structure”), corresponding to an overdispersion term.

MCMCglmm assumes additive overdispersion and this is responsible for the residual term in the model.

```{r}
# Scaling factor for MCMCglmm iterations
sc <- 1000 # Increase this parameter for longer runs

prior_years <- list(G = list(G1 = list(V = diag(1), nu = 1)), # for random effect of id 
                 R = list(R1 = list(V = diag(1), nu = 2))) 
```

#### Year*(intercept+slope)

How to test if the interactions year:intercept and year:slope are significant?
We should use year as a factor.
Fitting model with and wihtout year and the interactions, and looking at difference in DIC?

```{r, eval=FALSE, include=TRUE}
model_years_abs_bayes <- MCMCglmm(round(n_intact_seeds)~as.factor(year)*(intercept+slope),
                     random = ~ id,
                     rcov = ~units,
                     data = data_5yrs,
                     prior = prior_years, 
                     family = "poisson",
                     nitt = 2100 * sc, thin = sc, burnin = 100 * sc, verbose = F)
# nitt = burnin + thin*(n samples to keep)
# Aim to store 2000 iterations
save(model_years_abs_bayes,file="C:/Users/User/Dropbox/SU/Projects/lathyrus/lathyrus_ms2/code/objects/model_years_abs_bayes.RData")
```

```{r}
summary(model_years_abs_bayes)
```

#### Year*slope

```{r, eval=FALSE, include=TRUE}
model_years_abs_slope_bayes <- MCMCglmm(round(n_intact_seeds)~as.factor(year)*slope,
                     random = ~ id,
                     rcov = ~units,
                     data = data_5yrs,
                     prior = prior_years, 
                     family = "poisson",
                     nitt = 2100 * sc, thin = sc, burnin = 100 * sc, verbose = F)
# nitt = burnin + thin*(n samples to keep)
# Aim to store 2000 iterations
save(model_years_abs_slope_bayes,file="C:/Users/User/Dropbox/SU/Projects/lathyrus/lathyrus_ms2/code/objects/model_years_abs_slope_bayes.RData")
```

```{r}
summary(model_years_abs_slope_bayes)
```

#### Temp*(intercept+slope)

```{r, eval=FALSE, include=TRUE}
model_years_abs_temp_bayes <- MCMCglmm(round(n_intact_seeds)~cmean_4*(intercept+slope),
                     random = ~ id,
                     rcov = ~units,
                     data = data_5yrs,
                     prior = prior_years, 
                     family = "poisson",
                     nitt = 2100 * sc, thin = sc, burnin = 100 * sc, verbose = F)
# nitt = burnin + thin*(n samples to keep)
# Aim to store 2000 iterations
save(model_years_abs_temp_bayes,file="C:/Users/User/Dropbox/SU/Projects/lathyrus/lathyrus_ms2/code/objects/model_years_abs_temp_bayes.RData")
```

```{r}
summary(model_years_abs_temp_bayes)
vif(model_years_abs_temp_bayes) # High VIFs for intercept and slope
```

#### Temp*slope

```{r, eval=FALSE, include=TRUE}
model_years_abs_temp_slope_bayes <- MCMCglmm(round(n_intact_seeds)~cmean_4*slope,
                     random = ~ id,
                     rcov = ~units,
                     data = data_5yrs,
                     prior = prior_years, 
                     family = "poisson",
                     nitt = 2100 * sc, thin = sc, burnin = 100 * sc, verbose = F)
# nitt = burnin + thin*(n samples to keep)
# Aim to store 2000 iterations
save(model_years_abs_temp_slope_bayes,file="C:/Users/User/Dropbox/SU/Projects/lathyrus/lathyrus_ms2/code/objects/model_years_abs_temp_slope_bayes.RData")
```

```{r}
summary(model_years_abs_temp_slope_bayes)
vif(model_years_abs_temp_slope_bayes)
```

#### Temp*slope+volume

```{r, eval=FALSE, include=TRUE}
model_years_abs_temp_slope_vol_bayes <- MCMCglmm(round(n_intact_seeds)~cmean_4*slope+sqrt(shoot_vol), # Center shoot_vol?
                     random = ~ id,
                     rcov = ~units,
                     data = subset(data_5yrs,shoot_vol>0), # There was one case with shoot_vol=0!
                     prior = prior_years, 
                     family = "poisson",
                     nitt = 2100 * sc, thin = sc, burnin = 100 * sc, verbose = F)
# nitt = burnin + thin*(n samples to keep)
# Aim to store 2000 iterations
save(model_years_abs_temp_slope_vol_bayes,file="C:/Users/User/Dropbox/SU/Projects/lathyrus/lathyrus_ms2/code/objects/model_years_abs_temp_slope_vol_bayes.RData")
```

```{r}
summary(model_years_abs_temp_slope_vol_bayes)
vif(model_years_abs_temp_slope_vol_bayes)
```

#### Volume*slope

```{r, eval=FALSE, include=TRUE}
model_years_abs_slope_vol_bayes <- MCMCglmm(round(n_intact_seeds)~sqrt(shoot_vol)*slope, # Center shoot_vol?
                     random = ~ id,
                     rcov = ~units,
                     data = subset(data_5yrs,shoot_vol>0),
                     prior = prior_years, 
                     family = "poisson",
                     nitt = 2100 * sc, thin = sc, burnin = 100 * sc, verbose = F)
# nitt = burnin + thin*(n samples to keep)
# Aim to store 2000 iterations
save(model_years_abs_slope_vol_bayes,file="C:/Users/User/Dropbox/SU/Projects/lathyrus/lathyrus_ms2/code/objects/model_years_abs_slope_vol_bayes.RData")
```

```{r}
summary(model_years_abs_slope_vol_bayes)
vif(model_years_abs_slope_vol_bayes)
```

#### Temp*slope+volume*slope

```{r, eval=FALSE, include=TRUE}
model_years_abs_temp_slope_vol_int_bayes <- MCMCglmm(round(n_intact_seeds)~cmean_4*slope+
                                                       sqrt(shoot_vol)*slope, # Center shoot_vol?
                     random = ~ id,
                     rcov = ~units,
                     data = subset(data_5yrs,shoot_vol>0),
                     prior = prior_years, 
                     family = "poisson",
                     nitt = 2100 * sc, thin = sc, burnin = 100 * sc, verbose = F)
# nitt = burnin + thin*(n samples to keep)
# Aim to store 2000 iterations
save(model_years_abs_temp_slope_vol_int_bayes,file="C:/Users/User/Dropbox/SU/Projects/lathyrus/lathyrus_ms2/code/objects/model_years_abs_temp_slope_vol_int_bayes.RData")
```

```{r}
summary(model_years_abs_temp_slope_vol_int_bayes)
vif(model_years_abs_temp_slope_vol_int_bayes)
```

## Model with relative fitness (not used)

```{r}
data_5yrs_means<-data_5yrs%>%group_by(year)%>%
  dplyr::summarise(n_intact_seeds_mean=mean(n_intact_seeds))
data_5yrs<-data_5yrs%>%left_join(data_5yrs_means,by="year")
# Relativize fitness within years
data_5yrs$n_intact_seeds_rel_y<-with(data_5yrs,n_intact_seeds/n_intact_seeds_mean)
```

```{r}
model_years_rel<-glmmTMB(n_intact_seeds_rel_y~intercept+slope+
                           as.factor(year):intercept+as.factor(year):slope+(1|id),
                         subset(data_5yrs,year<2017),family=gaussian) 
# Gaussian model, but fit should be bad
# summary(model_years_rel)
Anova(model_years_rel)
```


# TO DO

Things that I would like to do next, but I am unsure about how to modify the code (MCMCglmm models and priors) to achieve this:

* Include interaction between year and intercept/slope of the RN in the random part of the MCMCglmm models: to see if selection varies among years (now trying this by fitting yearly models) (To answer question 3)

* Include interaction between temperature and intercept/slope of the RN in the random part of the MCMCglmm models: to see if among-year variation in selection is related to temperature (To answer question 4)

* Include interaction between plant size (shoot volume) and intercept/slope of the RN in the random part of the MCMCglmm models: to see if selection varies with size (in the same model, without using the BLUPs as above)
