---
title: "Lathyrus ms2: selection on reaction norms for flowering time"
subtitle: "Models with all data performed with MCMCglmm and brms"
author : "Alicia Vald√©s"
output:
  pdf_document:
    toc: yes
    toc_depth: 4
  html_notebook:
    toc: yes
    toc_depth: '4'
    latex_engine: xelatex
editor_options:
  chunk_output_type: inline
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(warning = FALSE, message = FALSE) 
```

```{r load packages, include=FALSE}
library(tidyverse)
library(tidyr)
library(MCMCglmm)
library(brms)
library(parallel)
library(beepr)
library(ggthemes)
library(knitr)
```

```{r Define ggplot themes, include=FALSE}
my_theme <- function(){
  theme_base()+theme(plot.background=element_rect(fill="white", colour=NA))+
  theme(legend.position="none")+theme(text=element_text(family="serif"))+
  theme(plot.title = element_text(hjust =-0.06))
}
my_theme_legend <- function(){
  theme_base()+theme(plot.background=element_rect(fill="white", colour=NA))+
  theme(text=element_text(family="serif"))+
  theme(plot.title = element_text(hjust =-0.06))
}
```

```{r include=FALSE}
# function to calculate vif for MCMCglmm
# Taken from https://github.com/aufrank/R-hacks/blob/master/MCMCglmm-utils.R#L2
vif.MCMCglmm <- function (fit, intercept.columns = c(1)) {
    nF <- fit$Fixed$nfl
    v <- cov(as.matrix(fit$X[,1:nF]))
    nam <- colnames(fit$Sol[,1:nF])

    v <- v[-intercept.columns, -intercept.columns, drop = FALSE]
    nam <- nam[-intercept.columns]
    
    d <- diag(v)^0.5
    v <- diag(solve(v/(d %o% d)))
    names(v) <- nam
    v
}
```

```{r load models, include=FALSE}
# Load previously run models so that they are not run when knitting (takes long time)
load("output/univar.FFD.all.RData")
load("output/univar.FFD_RR.all.RData")
load("output/univar.FFD.all.brm.RData")
load("output/univar.FFD_RR.all.brm.RData")
load("output/bivar1.all.RData")
load("output/bivar2.all.RData")
load("output/bivar1.all.brm.nb.RData")
load("output/bivar1.all.brm.OLRE.RData")
load("output/bivar1.all.brm.pois.RData")
load("output/bivar2.all.brm.nb.RData")
load("output/bivar3.all.brm.nb.RData")
load("output/bivar3.all.RData")
load("output/bivar4.all.RData")
load("output/bivar4.all.brm.nb.RData")
```

Read data

```{r}
datadef<-read.csv(
  "data/datadef.csv") 
head(datadef)
```

Number of individuals in each period:

```{r}
length(with(subset(datadef,period=="old"),unique(id)))
length(with(subset(datadef,period=="new"),unique(id)))
```

Number of observations in each period:

```{r}
nrow(subset(datadef,period=="old"))
nrow(subset(datadef,period=="new"))
```

Number of cases with FFD in each period:

```{r}
nrow(subset(datadef,period=="old"&!is.na(FFD)))
nrow(subset(datadef,period=="new"&!is.na(FFD)))
```

# Univariate models

## MCMCglmm

Code based on Arnold et al. 2019 Phil. Trans. R. Soc. B.

```{r sc and priors}
# Scaling factor for MCMCglmm iterations
sc <- 1000 # Increase this parameter for longer runs

priorUV2 <- list(G = list(G1 = list(V = diag(1), nu = 1),
                          # for random effect of year
                          G2 = list(V = diag(1), nu = 1)),
                 # for random effect of id 
                 R = list(R1 = list(V = diag(1), nu = 2))) 
priorUV2_RR <- list(G = list(G1 = list(V = diag(1), nu = 1),  
                             # other random effect (YEAR)
                             G2 = list(V = diag(2), nu = 1)),
                    # ^ 2x2 var-covar matrix for var in slopes + intercepts
                    R = list(R1 = list(V = diag(1), nu = 2)))  
```

### FFD with random effects of year and individual-intercept

```{r MCMCglmm univar 1, eval=FALSE, include=TRUE}
univar.FFD.all <- MCMCglmm(FFD ~ cmean_4,
                     random = ~year + id,
                     rcov = ~units,
                     data = datadef,prior = priorUV2, 
                     family = "gaussian",nitt = 2100 * sc, 
                     thin = sc, burnin = 100 * sc, verbose = F)
# nitt = burnin + thin*(n samples to keep)
# Aim to store 2000 iterations
save(univar.FFD.all,
     file="output/univar.FFD.all.RData")
```

```{r MCMCglmm univar 2}
summary(univar.FFD.all)
```

### Random regression for FFD, including random effects of individual slopes and covariance between intercept and slope

```{r MCMCglmm univar 3, eval=FALSE, include=TRUE}
univar.FFD_RR.all <- MCMCglmm(FFD ~ cmean_4,
                        random = ~year + us(1 + cmean_4):id,
                        rcov = ~units,
                        data = datadef,prior = priorUV2_RR, 
                        family = "gaussian",nitt = 2100*sc,
                        thin = sc, burnin = 100*sc, verbose = F,pr=T) 
# pr= T saves the posterior distribution of the individual random effects
# (analagous to the BLUP from the LMM)
save(univar.FFD_RR.all,
     file="output/univar.FFD_RR.all.RData")
```

```{r MCMCglmm univar 4}
summary(univar.FFD_RR.all)
```

#### Extract BLUPs from this model

Code adapted from Houslay & Wilson 2017 Behav. Ecol. Code for graphs based on Arnold et al. 2019 Phil. Trans. R. Soc. B.

```{r extract BLUPs, fig.height=5, fig.width=6, message=FALSE, warning=FALSE}
BLUPs_MCMC.all <- tibble(Trait = attr(colMeans(univar.FFD_RR.all$Sol), "names"),
                          Value = colMeans(univar.FFD_RR.all$Sol)) %>%
  filter(grepl("id", Trait))%>% # Select only id intercepts and slopes
  mutate(type=ifelse(grepl("Intercept",Trait),"intercept","slope"))%>%
  mutate(id=sub(".*id.", "", Trait))%>%
  select(-Trait)%>%
  spread(., type, Value) # Convert from long to wide
with(BLUPs_MCMC.all,cor(intercept,slope)) # highly correlated!
```

Correlation among intercepts and slopes

```{r corr1, fig.height=2.5, fig.width=6}
univar.FFD_RR.all_intslope <- 
  univar.FFD_RR.all$VCV[,"cmean_4:(Intercept).id"]/
(sqrt(univar.FFD_RR.all$VCV[,"(Intercept):(Intercept).id"])*
sqrt(univar.FFD_RR.all$VCV[,"cmean_4:cmean_4.id"]))
posterior.mode(univar.FFD_RR.all_intslope)
HPDinterval(univar.FFD_RR.all_intslope) 
```

Plots with BLUPs

```{r, echo=FALSE, fig.height=4, fig.width=10}
ggplot(BLUPs_MCMC.all, aes(id, intercept)) + 
  geom_point(aes(group = id, colour = id), size = 4, alpha = 0.5) + 
  ylab("BLUP intercept estimate") +
  geom_hline(yintercept = 0, lty = 2) + my_theme() +
  theme(axis.text.x = element_blank())
```

```{r, echo=FALSE, fig.height=4, fig.width=10}
ggplot(BLUPs_MCMC.all, aes(id, slope)) + 
  geom_point(aes(group = id, colour = id), size = 4, alpha = 0.5) + 
  ylab("Plasticity (BLUP slope estimate)") +
  geom_hline(yintercept = 0, lty = 2) + my_theme() +
  theme(axis.text.x = element_blank())
```

```{r BLUPs_all20, echo=FALSE, fig.height=4, fig.width=4}
ggplot(BLUPs_MCMC.all, aes(intercept, slope)) +
  geom_point(aes(group = id, colour = id), size = 2, alpha = 0.5) +
  xlab("BLUP intercept estimate") +
  ylab("BLUP slope estimate") + my_theme()
```

```{r BLUPs_all21, echo=FALSE, fig.height=4, fig.width=10}
BLUPs_MCMC.all$id_ordered <- factor(BLUPs_MCMC.all$id,
                                    levels = BLUPs_MCMC.all$id[order(BLUPs_MCMC.all$slope)])
ggplot(BLUPs_MCMC.all, aes(id_ordered, slope)) +
  geom_bar(stat = "identity", aes(group = id, fill = id)) +
  xlab("Id (in ranked order of plasticity)") +
  ylab("Plasticity (BLUP slope estimate)") +
  my_theme() + theme(axis.text.x = element_blank())
```

## brms

### FFD with random effects of year and individual-intercept

```{r}
my.cores <- detectCores()
```

```{r eval=FALSE, message=FALSE, warning=FALSE, include=TRUE}
univar.FFD.all.brm<-brm(formula=FFD~cmean_4+(1|year)+(1|id),data=datadef,
                warmup = 1000,iter = 4000,thin=2,chains=4,
                inits = "random",seed = 12345,cores = my.cores)
# Total of 6000 post-warmup samples
save(univar.FFD.all.brm,
     file="output/univar.FFD.all.brm.RData")
```

```{r }
summary(univar.FFD.all.brm)
```

### Random regression for FFD, including random effects of individual slopes and covariance between intercept and slope

```{r, eval=FALSE, include=TRUE}
univar.FFD_RR.all.brm<-brm(formula=FFD~cmean_4+(1|year)+(cmean_4|id),data=datadef,
                warmup = 1000,iter = 4000,thin=2,chains=4,
                inits = "random",seed = 12345,cores = my.cores)
# Total of 6000 post-warmup samples
save(univar.FFD_RR.all.brm,
     file="output/univar.FFD_RR.all.brm.RData")
```

```{r}
summary(univar.FFD_RR.all.brm) 
```

#### Extract BLUPs from this model

This code needs to be checked - not sure that this is the correct way to extract BLUPs!

```{r}
BLUPs_MCMC.all.brms  <- cbind(as.factor(c(1:837)),
                              as.data.frame(ranef(univar.FFD_RR.all.brm)$id)
                              [c(1,5)])
colnames(BLUPs_MCMC.all.brms) <- c("id", "intercept", "slope")
with(BLUPs_MCMC.all.brms,cor(intercept,slope)) # highly correlated!
```

Plots with BLUPs

```{r, echo=FALSE, fig.height=4, fig.width=10}
ggplot(BLUPs_MCMC.all.brms, aes(id, intercept)) + 
  geom_point(aes(group = id, colour = id), size = 4, alpha = 0.5) + 
  ylab("BLUP intercept estimate") +
  geom_hline(yintercept = 0, lty = 2) + my_theme() +
  theme(axis.text.x = element_blank())
```

```{r, echo=FALSE, fig.height=4, fig.width=10}
ggplot(BLUPs_MCMC.all.brms, aes(id, slope)) + 
  geom_point(aes(group = id, colour = id), size = 4, alpha = 0.5) + 
  ylab("Plasticity (BLUP slope estimate)") +
  geom_hline(yintercept = 0, lty = 2) + my_theme() +
  theme(axis.text.x = element_blank())
```

```{r, echo=FALSE, fig.height=4, fig.width=10}
BLUPs_MCMC.all.brms$id_ordered <- factor(BLUPs_MCMC.all.brms$id,
                                    levels = BLUPs_MCMC.all.brms$id[order(BLUPs_MCMC.all.brms$slope)])
ggplot(BLUPs_MCMC.all.brms, aes(id_ordered, slope)) +
  geom_bar(stat = "identity", aes(group = id, fill = id)) +
  xlab("Id (in ranked order of plasticity)") +
  ylab("Plasticity (BLUP slope estimate)") +
  my_theme() + theme(axis.text.x = element_blank())
```

## Compare results of MCMCglmm and brms

Fixed effects can be compared directly between MCMCglmm and brms outputs.

From Pieter's email: The group-level (random) effects reported by brms are standard deviations and correlations rather than the variances and covariances that mcmcglmm outputs. We need to square all the mcmc samples from the posterior then take their mean to get true estimates of the variance from brms (then we can compare them).

The code for these comparisons needs to be checked!

### FFD with random effects of year and individual-intercept

```{r}
kable(rbind(MCMCglmm=summary(univar.FFD.all)$solutions[,1],
      brms=summary(univar.FFD.all.brm)$fixed[,1])) # Comparison fixed effects

univar.FFD.all.brm_asmcmc <- as.mcmc(univar.FFD.all.brm, combine_chains = TRUE)
#head(univar.FFD.all.brm_asmcmc) # check which column the parameters are in

univar.FFD.all.brm_year <- (univar.FFD.all.brm_asmcmc[,4]^2)  
# sd_year__Intercept^2
univar.FFD.all.brm_id_intercept <- (univar.FFD.all.brm_asmcmc[,3]^2)  
# sd_id__Intercept^2 (individual intercept)
univar.FFD.all.brm_resid <- (univar.FFD.all.brm_asmcmc[,5]^2) 
# sigma^2 (residual)

kable(rbind(MCMCglmm=summary(univar.FFD.all$VCV)$statistics[,1],
      brms=as.vector(cbind(mean(univar.FFD.all.brm_year),
                           mean(univar.FFD.all.brm_id_intercept),
            mean(univar.FFD.all.brm_resid))))) # Comparison random effects

# Calculate 95% CI interval of the converted values
# round(HPDinterval(univar.FFD.all.brm_id_intercept), 2)
# round(HPDinterval(univar.FFD.all.brm_year), 2)
# round(HPDinterval(univar.FFD.all.brm_resid), 2)
```

Quite similar values.

### Random regression for FFD, including random effects of individual slopes and covariance between intercept and slope

```{r}
kable(rbind(MCMCglmm=summary(univar.FFD_RR.all)$solutions[,1],
      brms=summary(univar.FFD_RR.all.brm)$fixed[,1])) # Comparison fixed effects

univar.FFD_RR.all.brm_asmcmc <- as.mcmc(univar.FFD_RR.all.brm, 
                                        combine_chains = TRUE)
#head(univar.FFD_RR.all.brm_asmcmc) # check which column the parameters are in

univar.FFD_RR.all.brm_year <- (univar.FFD_RR.all.brm_asmcmc[,5]^2)  
# sd_year__Intercept^2
univar.FFD_RR.all.brm_id_intercept <- (univar.FFD_RR.all.brm_asmcmc[,3]^2)  
# sd_id__Intercept^2 (individual intercept)
univar.FFD_RR.all.brm_year_cor_id_intercept_cmean_4<-(univar.FFD_RR.all.brm_asmcmc[,6]^2) 
#cor_id__Intercept__cmean_4^2 (corr intercept-slope)
univar.FFD_RR.all.brm_year_sd_id_cmean_4<-(univar.FFD_RR.all.brm_asmcmc[,4]^2)
#sd_id__cmean_4^2 (individual slope)
univar.FFD_RR.all.brm_resid <- (univar.FFD_RR.all.brm_asmcmc[,7]^2) 
# sigma^2 (residual)

kable(cbind(MCMCglmm=summary(univar.FFD_RR.all$VCV)$statistics[,1],
      brms=as.vector(cbind(mean(univar.FFD_RR.all.brm_year),
                           mean(univar.FFD_RR.all.brm_id_intercept),
                           mean(univar.FFD_RR.all.brm_year_cor_id_intercept_cmean_4),
                           mean(univar.FFD_RR.all.brm_year_cor_id_intercept_cmean_4),
                           mean(univar.FFD_RR.all.brm_year_sd_id_cmean_4),
                           mean(univar.FFD_RR.all.brm_resid))))) 
# Comparison random effects
```

# Bivariate models

## MCMCglmm

Code based on Arnold et al. 2019 Phil. Trans. R. Soc. B.

Fitting bivariate models of fitness and FFD, with random regressions for individuals, using a Poisson distribution for fitness (and using absolute fitness). Using mean April temperature. Using either mean fitness per year of study (dividing sum of fitness by the number of years that each plant was included in the study) or mean fitness per flowering event (dividing sum of fitness by the number of years that each plant flowered and which had fitness information available). Including / not including mean shoot volume over all years with available data (with an effect on fitness) as a condition variable.

Data preparation

```{r data prep MCMCglmm, message=FALSE, warning=FALSE}
datadef_total<-datadef %>%
  group_by(id)%>%
  summarise(mean_fitness_study=sum(intactseed,na.rm=T)/mean(n_years_study),
            mean_fitness_fl=sum(intactseed,na.rm=T)/mean(n_years_fl_fitness))%>%
   arrange(.,id) # Order by id

with(datadef_total,cor(mean_fitness_study,mean_fitness_fl))  # Highly corr (0.87)

# Calculate mean shoot volume for each id using values of shoot volume for all ids/years
# (including flowering and non-flowering years)

shoot_vol_all_means<-datadef[c(1,3,10)]%>%
  group_by(id)%>%
  summarise(shoot_vol_mean=mean(shoot_vol,na.rm=T)) # Mean of all available values 

# Join shoot volume data
datadef_total<-datadef_total%>%left_join(shoot_vol_all_means)%>%
  left_join(unique(datadef[c(2,3,11)]))
head(datadef_total)
nrow(subset(datadef_total,is.na(shoot_vol_mean))) 
# 46 ids with no info on shoot volume
```

Compare distributions of mean fitness per year of study and mean fitness per flowering event between old and new periods:

```{r message=FALSE, warning=FALSE}
ggplot(datadef_total,aes(x=mean_fitness_study))+
  geom_histogram(colour="black",fill="white",position="dodge")+
  facet_wrap(~period,scales="free_y")+
  geom_vline(data=plyr::ddply(datadef_total,"period",summarise,
                        mean_fitness_study.mean=mean(mean_fitness_study)),
             aes(xintercept=mean_fitness_study.mean),
             linetype="dashed", size=1, colour="red")
ggplot(datadef_total,aes(x=mean_fitness_fl))+
  geom_histogram(colour="black",fill="white",position="dodge")+
  facet_wrap(~period,scales="free_y")+
  geom_vline(data=plyr::ddply(datadef_total,"period",summarise,
                        mean_fitness_fl.mean=mean(mean_fitness_fl)),
             aes(xintercept=mean_fitness_fl.mean),
             linetype="dashed", size=1, colour="red")
```

Distributions and means of the two mean fitness measures are similar among the two periods.

### Mean fitness per flowering event

#### With no condition variable

Stack data:

```{r}
# Create a single data-set "datadef.stack1", with single column at start 
# to index observations
datadef.stack1 <- c()
datadef.stack1$Obs <- 1:(837 + 2478) 
datadef.stack1$id <- c(as.character(datadef_total$id),
                      as.character(subset(datadef,!is.na(FFD))$id)) 
# ids in alphabetical order

# Add first_yr to total data + 
# Year column is only relevant for FFD, but is set to first_yr for fitness values
datadef_total$first_yr<-ifelse(grepl("old",as.character(datadef_total$id)),1987,2006)
datadef.stack1$year <- c(datadef_total$first_yr,
                         subset(datadef,!is.na(FFD))$year)

# Temperature column is only relevant for FFD, but is set to 0 for fitness values
datadef.stack1$temp <- c(rep(0, 837), subset(datadef,!is.na(FFD))$cmean_4)

# Create single column with first fitness values (ABSOLUTE VALUES), then FFD values:
datadef.stack1$fitness.FFD.stack <- c(round(datadef_total$mean_fitness_fl),
                                     subset(datadef,!is.na(FFD))$FFD)

# Create 3 index columns needed for MCMCglmm
datadef.stack1$traits <- as.factor(c(rep("fitness", 837), rep("FFD", 2478)))
datadef.stack1$variable <- as.factor(datadef.stack1$traits)
# Fitness will be modelled with an overdispersed Poisson 
# FFD will be modelled with a Gaussian distribution
# Specify this with the column 'family':
datadef.stack1$family <- c(rep("poisson", 837), rep("gaussian", 2478))
datadef.stack1 <- data.frame(datadef.stack1)

datadef.stack1$id <- as.factor(datadef.stack1$id)
datadef.stack1$year <- as.factor(datadef.stack1$year)
head(datadef.stack1)
```

```{r}
# Scaling factor for MCMCglmm iterations
sc <- 1000 # Increase this parameter for longer runs

priorBiv <- list(G = list(G1 = list(V = diag(1), nu = 1)),
                    # ^ random effect for year (fitted for FFD only)
                    R = list(R1 = list(V = diag(3), nu = 3, covu = TRUE), 
                             # ^ 3-way var-cov matrix of (id + temp:id) for FFD,
                             # residual for fitness
                             R2 = list(V = diag(1), nu = 1))) # residual for FFD
```

```{r MCMCglmm models 1, eval=FALSE, include=TRUE}
bivar1.all <- MCMCglmm(fitness.FFD.stack ~ variable - 1 +
                         # ^ means for each variable 
                         # (and no overall mean (hence "-1"))
                         at.level(variable, "FFD"):temp,  
                       # single fixed effect of temp
                       random = ~us(at.level(variable, "FFD")):year +
                         us(at.level(variable, "FFD") + 
                              at.level(variable,"FFD"):temp):id,
                       # ^ random intercepts for individual, 
                       # and random slopes for temp|id
                       rcov = ~us(at.level(variable, "fitness")):id + 
                         # ^ variance between indivdiuals in fitness
                         # (which is residual variance)
                         us(at.level(variable, "FFD")):Obs,    
                         # ^ residual variance within indivdiuals between years 
                       # (labelled by 'Obs')
                       data = datadef.stack1,
                       prior = priorBiv, 
                       family = NULL, # specified already in the data-set
                       nitt = 2100 * sc, thin = sc, burnin = 100 * sc, 
                       verbose = F,singular.ok = T) 
# nitt = burnin + thin*(n samples to keep)
# Aim to store 2000 iterations
save(bivar1.all,file="output/bivar1.all.RData")
```

```{r}
kable(summary(bivar1.all)$solutions,digits=c(3,3,3,0,3),caption="Fixed effects")
kable(summary(bivar1.all)$Gcovariances,digits=c(3,3,3,0),caption="Random effects")
kable(summary(bivar1.all)$Rcovariances,digits=c(3,3,3,0),caption="Random effects")
kable(diag(autocorr(bivar1.all$Sol)[2, , ]),caption="Autocorrelation")
kable(diag(autocorr(bivar1.all$VCV)[2, , ]),caption="Autocorrelation")
```

For interpretation of covariances, we convert them to correlations using the formula for a correlation with the posterior distributions of our (co)variance components. This gives us a distribution of correlation values that we can use to calculate estimates and 95% credible intervals (code adapted from Houslay & Wilson 2017 Behav. Ecol.).

Among-individual correlation between intercepts and slopes for FFD, between FFD and fitness and between fitness and variation in slopes for FFD:

```{r MCMCglmm models 6, fig.height=2.5, fig.width=6}
cor_bivar1.all_intslope <- 
  bivar1.all$VCV[,"at.level(variable, \"FFD\"):temp.id:at.level(variable, \"FFD\").id"]/
(sqrt(bivar1.all$VCV[,"at.level(variable, \"FFD\").id:at.level(variable, \"FFD\").id"])*
sqrt(bivar1.all$VCV[,"at.level(variable, \"FFD\"):temp.id:at.level(variable, \"FFD\"):temp.id"]))
posterior.mode(cor_bivar1.all_intslope)
HPDinterval(cor_bivar1.all_intslope) 

cor_bivar1.all_intfit <-
  bivar1.all$VCV[,"at.level(variable, \"fitness\").id:at.level(variable, \"FFD\").id"]/
  (sqrt(bivar1.all$VCV[,"at.level(variable, \"fitness\").id:at.level(variable, \"fitness\").id"])*
     sqrt(bivar1.all$VCV[,"at.level(variable, \"FFD\").id:at.level(variable, \"FFD\").id"]))
posterior.mode(cor_bivar1.all_intfit)
HPDinterval(cor_bivar1.all_intfit)

cor_bivar1.all_slopefit <- 
  bivar1.all$VCV[,"at.level(variable, \"fitness\").id:at.level(variable, \"FFD\"):temp.id"]/
  (sqrt(bivar1.all$VCV[,"at.level(variable, \"fitness\").id:at.level(variable, \"fitness\").id"])*
     sqrt(bivar1.all$VCV[,"at.level(variable, \"FFD\"):temp.id:at.level(variable, \"FFD\"):temp.id"]))
posterior.mode(cor_bivar1.all_slopefit)
HPDinterval(cor_bivar1.all_slopefit)
```

Correlation between intercepts and slopes for FFD is smaller than in univariate models. Why?

Intercepts and slopes of RNs are positively correlated: Plants that flower earlier on average are also more responsive to temperature. Fitness is negatively correlated with the intercept, but not with the slope of the RN: individuals that flower earlier on average have higher fitness, but responsiveness to temperature does not seem to affect fitness.

##### Extract selection coefficients

Selection differentials or gradients should be calculated using relative fitness, and models are typically fitted assuming Gaussian errors. However, where the fitness measure follows a non-Gaussian distribution, as is typically the case with skewed distributions of fitness, a GLMM of absolute fitness will be preferable. The resulting covariances returned by the model will then be between the trait on the data scale and fitness on a 'latent' (link-function) scale. These estimates need to be transformed if data-scale estimates of selection are required. However, in the case of a GLMM with a log-link function (e.g. Poisson here), it is possible to exploit the fact that the latent-scale covariance with absolute fitness is equivalent to the data-scale covariance of relative fitness: consequently, and conveniently, the covariance components of the var-covar matrix on the latent scale can simply be treated as selection differentials S. By extension, estimates of selection gradients will also provide data-scale selection gradients.

```{r fig.height=2.5, fig.width=6}
# Extract 3x3 matrix of variance-covariance values for intercepts and slopes 
# of temp, and fitness 
# These are in the 2nd-10th columns of model output
P.bivar1.all <- bivar1.all$VCV[,2:10]         
P.bivar1.all.mode <- matrix(1:9, nrow = 3)
for (k in 1:9) P.bivar1.all.mode[k] <- posterior.mode(P.bivar1.all[,k])
P.bivar1.all.mode

# Extract selection *differentials* (i.e. covariances) for intercept and slope:
# and calculate posterior mode and credible intervals for each
S.bivar1.all <- bivar1.all$VCV[, c(4,7)]
S.bivar1.all <- P.bivar1.all[, c(3,6)] # This is exactly the same as above
colnames(S.bivar1.all) <- c("S_intercepts", "S_slopes")
S.bivar1.all.mode <- P.bivar1.all.mode[1:2, 3]
S.bivar1.all.mode
posterior.mode(mcmc(S.bivar1.all)) # This is exactly the same as above
HPDinterval(mcmc(S.bivar1.all))

# Estimate selection gradients for intercept and slope (beta = S / P)
# on each sample of posterior and extract their mode
n <- length(bivar1.all$VCV[,2])   # sample size
beta_post_bivar1.all <- matrix(NA, n ,2)

for (i in 1:n) {
  P3 <- matrix(rep(NA, 9), nrow = 3)  
  # 3x3 matrix of var-cov for individual X.int, X.slope and fitness
  for (k in 1:9) {P3[k] <- P.bivar1.all[i, k] }  
  P2 <- P3[1:2, 1:2]   # 2x2 matrix of just trait intercept & slope var-cov
  S <- P3[1:2, 3]   # selection differentials on traits (last column of P3)
  beta_post_bivar1.all[i,] <- solve(P2) %*% S   # selection gradients beta = P^-1 * S
}

# Finally, extract and plot the selection gradients posterior modes 
# and 95% credible intervals for both selection on intercepts (trait value) 
# and slopes (trait plasticity).

colnames(beta_post_bivar1.all) <- c("beta_intercepts", "beta_slopes")
posterior.mode(mcmc(beta_post_bivar1.all))
HPDinterval(mcmc(beta_post_bivar1.all))
```

The selection differentials are "significant" for RN intercept (negative), but not for RN slope. The selection gradients are significant for both RN intercept (negative) and slope (positive). This means that there is significant total and direct selection on the intercept of the RN, selecting for an earlier flowering time on average. Not sure how to interpret the selection on the slope though. The selection differential is not significant, meaning that there is no total selection on the slope, but the selection gradient is significant and positive. I guess this means that, after correcting for the covariance between intercepts and slopes, there is significant selection on the slope. And the selection gradient for the slope being positive means that there is selection for more positive slopes (i.e. less negative = individuals less responsive to temperature, because the relationship among FFD and temperature is negative: earlier flowering (lower FFD) with higher temperatures). Am I interpreting this correctly?

#### With shoot volume

Stack data:

```{r}
# Create a single data-set "datadef.stack2", with single column at start 
# to index observations
datadef.stack2 <- c()
nrow(subset(datadef_total,!is.na(shoot_vol_mean))) # 791 ids with info on shoot_vol

nrow(subset(datadef,!is.na(FFD)&
              id %in% subset(datadef_total,!is.na(shoot_vol_mean))$id)) 
# 2432 cases with info on FFD and fitness 
# corresponding to the 791 ids with info on shoot_vol

# Check that those cases correspond to those 791 individuals
length(unique(subset(datadef,!is.na(FFD)&
         id %in% subset(datadef_total,!is.na(shoot_vol_mean))$id)$id))

datadef.stack2$Obs <- 1:(791 + 2432) 
datadef.stack2$id <- c(as.character(subset(datadef_total,!is.na(shoot_vol_mean))$id),
                      as.character(subset(datadef,!is.na(FFD)&
                            id %in% subset(datadef_total,!is.na(shoot_vol_mean))$id)$id)) 
# ids in alphabetical order

# Year column is only relevant for FFD, but is set to first_yr for fitness values
datadef.stack2$year <- c(subset(datadef_total,!is.na(shoot_vol_mean))$first_yr,
                         subset(datadef,!is.na(FFD)&
                                  id %in%subset(datadef_total,
                                                !is.na(shoot_vol_mean))$id)$year)

# Temperature column is only relevant for FFD, but is set to 0 for fitness values
datadef.stack2$temp <- c(rep(0, 791), 
                         subset(datadef,!is.na(FFD)&
                                  id %in%subset(datadef_total,
                                                !is.na(shoot_vol_mean))$id)$cmean_4)

# Shoot volume column is only relevant for fitness, but is set to 0 for FFD values
# Using sqrt of mean shoot volume over all years when available, centered
datadef_total<-datadef_total%>%
  mutate(shoot_vol_mean_sqrt=sqrt(shoot_vol_mean),
         cn_shoot_vol_mean_sqrt=scale(shoot_vol_mean_sqrt,center=T,scale=F))
datadef.stack2$cn_shoot_vol <- c(subset(datadef_total,
                                        !is.na(shoot_vol_mean))$cn_shoot_vol_mean_sqrt,
                                 rep(0, 2432))

# Create single column with first fitness values (ABSOLUTE VALUES), then FFD values:
datadef.stack2$fitness.FFD.stack <- c(round(subset(datadef_total,
                                                   !is.na(shoot_vol_mean))$mean_fitness_fl),
                                      subset(datadef,!is.na(FFD)&
                                               id %in%  subset(datadef_total,
                                                               !is.na(shoot_vol_mean))$id)$FFD)

# Create 3 index columns needed for MCMCglmm
datadef.stack2$traits <- as.factor(c(rep("fitness", 791), rep("FFD", 2432)))
datadef.stack2$variable <- as.factor(datadef.stack2$traits)
# Fitness will be modelled with an overdispersed Poisson 
# FFD will be modelled with a Gaussian distribution
# Specify this with the column 'family':
datadef.stack2$family <- c(rep("poisson", 791), rep("gaussian", 2432))
datadef.stack2 <- data.frame(datadef.stack2)

datadef.stack2$id <- as.factor(datadef.stack2$id)
datadef.stack2$year <- as.factor(datadef.stack2$year)
head(datadef.stack2)
```

```{r eval=FALSE, include=TRUE}
bivar2.all <- MCMCglmm(fitness.FFD.stack ~ variable - 1 +
                         # ^ means for each variable 
                         # (and no overall mean (hence "-1"))
                         at.level(variable, "FFD"):temp +  
                       # single fixed effect of temp
                         at.level(variable,"fitness"):cn_shoot_vol,
                       random = ~us(at.level(variable, "FFD")):year +
                         us(at.level(variable, "FFD") + 
                              at.level(variable,"FFD"):temp):id,
                       # ^ random intercepts for individual, 
                       # and random slopes for temp|id
                       rcov = ~us(at.level(variable, "fitness")):id + 
                         # ^ variance between indivdiuals in fitness
                         # (which is residual variance)
                         us(at.level(variable, "FFD")):Obs,    
                         # ^ residual variance within indivdiuals between years 
                       # (labelled by 'Obs')
                       data = datadef.stack2,
                       prior = priorBiv, 
                       family = NULL, # specified already in the data-set
                       nitt = 2100 * sc, thin = sc, burnin = 100 * sc, 
                       verbose = F,singular.ok = T) 
# nitt = burnin + thin*(n samples to keep)
# Aim to store 2000 iterations
save(bivar2.all,file="output/bivar2.all.RData")
```

```{r}
kable(summary(bivar2.all)$solutions,digits=c(3,3,3,0,3),caption="Fixed effects")
kable(summary(bivar2.all)$Gcovariances,digits=c(3,3,3,0),caption="Random effects")
kable(summary(bivar2.all)$Rcovariances,digits=c(3,3,3,0),caption="Random effects")
kable(diag(autocorr(bivar2.all$Sol)[2, , ]),caption="Autocorrelation")
kable(diag(autocorr(bivar2.all$VCV)[2, , ]),caption="Autocorrelation")
```

Among-individual correlation between intercepts and slopes for FFD, between FFD and fitness and between fitness and variation in slopes for FFD:

```{r fig.height=2.5, fig.width=6}
cor_bivar2.all_intslope <- 
  bivar2.all$VCV[,"at.level(variable, \"FFD\"):temp.id:at.level(variable, \"FFD\").id"]/
(sqrt(bivar2.all$VCV[,"at.level(variable, \"FFD\").id:at.level(variable, \"FFD\").id"])*
sqrt(bivar2.all$VCV[,"at.level(variable, \"FFD\"):temp.id:at.level(variable, \"FFD\"):temp.id"]))
posterior.mode(cor_bivar2.all_intslope)
HPDinterval(cor_bivar2.all_intslope)

cor_bivar2.all_intfit <-
  bivar2.all$VCV[,"at.level(variable, \"fitness\").id:at.level(variable, \"FFD\").id"]/
  (sqrt(bivar2.all$VCV[,"at.level(variable, \"fitness\").id:at.level(variable, \"fitness\").id"])*
     sqrt(bivar2.all$VCV[,"at.level(variable, \"FFD\").id:at.level(variable, \"FFD\").id"]))
posterior.mode(cor_bivar2.all_intfit)
HPDinterval(cor_bivar2.all_intfit)

cor_bivar2.all_slopefit <- 
  bivar2.all$VCV[,"at.level(variable, \"fitness\").id:at.level(variable, \"FFD\"):temp.id"]/
  (sqrt(bivar2.all$VCV[,"at.level(variable, \"fitness\").id:at.level(variable, \"fitness\").id"])*
     sqrt(bivar2.all$VCV[,"at.level(variable, \"FFD\"):temp.id:at.level(variable, \"FFD\"):temp.id"]))
posterior.mode(cor_bivar2.all_slopefit)
HPDinterval(cor_bivar2.all_slopefit)
```

Similar results as in model without shoot volume.

##### Extract selection coefficients

```{r fig.height=2.5, fig.width=6}
# Extract 3x3 matrix of variance-covariance values for intercepts and slopes 
# of temp, and fitness 
# These are in the 2nd-10th columns of model output
P.bivar2.all<- bivar2.all$VCV[,2:10]         
P.bivar2.all.mode <- matrix(1:9, nrow = 3)
for (k in 1:9) P.bivar2.all.mode[k] <- posterior.mode(P.bivar2.all
                                                    [,k])
P.bivar2.all.mode

# Extract selection *differentials* (i.e. covariances) for intercept and slope:
# and calculate posterior mode and credible intervals for each
S.bivar2.all <- bivar2.all$VCV[, c(4,7)]
S.bivar2.all <- P.bivar2.all[, c(3,6)] # This is exactly the same as above
colnames(S.bivar2.all) <- c("S_intercepts", "S_slopes")
S.bivar2.all.mode <- P.bivar2.all.mode[1:2, 3]
S.bivar2.all.mode
posterior.mode(mcmc(S.bivar2.all)) # This is exactly the same as above
HPDinterval(mcmc(S.bivar2.all))

# Estimate selection gradients for intercept and slope (beta = S / P)
# on each sample of posterior and extract their mode
n <- length(bivar2.all$VCV[,2])   # sample size
beta_post_bivar2.all <- matrix(NA, n ,2)

for (i in 1:n) {
  P3 <- matrix(rep(NA, 9), nrow = 3)  
  # 3x3 matrix of var-cov for individual X.int, X.slope and fitness
  for (k in 1:9) {P3[k] <- P.bivar2.all[i, k] }  
  P2 <- P3[1:2, 1:2]   # 2x2 matrix of just trait intercept & slope var-cov
  S <- P3[1:2, 3]   # selection differentials on traits (last column of P3)
  beta_post_bivar2.all[i,] <- solve(P2) %*% S   # selection gradients beta = P^-1 * S
}

# Finally, extract and plot the selection gradients posterior modes 
# and 95% credible intervals for both selection on intercepts (trait value) 
# and slopes (trait plasticity).

colnames(beta_post_bivar2.all) <- c("beta_intercepts", "beta_slopes")
posterior.mode(mcmc(beta_post_bivar2.all))
HPDinterval(mcmc(beta_post_bivar2.all))
```

Selection coefficients give similar results as in model without shoot volume.

### Mean fitness per year of study

#### With no condition variable

Stack data:

```{r}
# Create a single data-set "datadef.stack3", with single column at start 
# to index observations
datadef.stack3 <- c()
datadef.stack3$Obs <- 1:(837 + 2478) 
datadef.stack3$id <- c(as.character(datadef_total$id),
                      as.character(subset(datadef,!is.na(FFD))$id)) 
# ids in alphabetical order

# Year column is only relevant for FFD, but is set to first_yr for fitness values
datadef.stack3$year <- c(datadef_total$first_yr,
                         subset(datadef,!is.na(FFD))$year)

# Temperature column is only relevant for FFD, but is set to 0 for fitness values
datadef.stack3$temp <- c(rep(0, 837), subset(datadef,!is.na(FFD))$cmean_4)

# Create single column with first fitness values (ABSOLUTE VALUES), then FFD values:
datadef.stack3$fitness.FFD.stack <- c(round(datadef_total$mean_fitness_study),
                                      subset(datadef,!is.na(FFD))$FFD)

# Create 3 index columns needed for MCMCglmm
datadef.stack3$traits <- as.factor(c(rep("fitness", 837), rep("FFD", 2478)))
datadef.stack3$variable <- as.factor(datadef.stack3$traits)
# Fitness will be modelled with an overdispersed Poisson 
# FFD will be modelled with a Gaussian distribution
# Specify this with the column 'family':
datadef.stack3$family <- c(rep("poisson", 837), rep("gaussian", 2478))
datadef.stack3 <- data.frame(datadef.stack3)

datadef.stack3$id <- as.factor(datadef.stack3$id)
datadef.stack3$year <- as.factor(datadef.stack3$year)
head(datadef.stack3)
```

```{r eval=FALSE, include=TRUE}
bivar3.all <- MCMCglmm(fitness.FFD.stack ~ variable - 1 +
                         # ^ means for each variable 
                         # (and no overall mean (hence "-1"))
                         at.level(variable, "FFD"):temp,  
                       # single fixed effect of temp
                       random = ~us(at.level(variable, "FFD")):year +
                         us(at.level(variable, "FFD") + 
                              at.level(variable,"FFD"):temp):id,
                       # ^ random intercepts for individual, 
                       # and random slopes for temp|id
                       rcov = ~us(at.level(variable, "fitness")):id + 
                         # ^ variance between indivdiuals in fitness
                         # (which is residual variance)
                         us(at.level(variable, "FFD")):Obs,    
                         # ^ residual variance within indivdiuals between years 
                       # (labelled by 'Obs')
                       data = datadef.stack3,
                       prior = priorBiv, 
                       family = NULL, # specified already in the data-set
                       nitt = 2100 * sc, thin = sc, burnin = 100 * sc, 
                       verbose = F,singular.ok = T) 
# nitt = burnin + thin*(n samples to keep)
# Aim to store 2000 iterations
save(bivar3.all,file="output/bivar3.all.RData")
```

```{r}
kable(summary(bivar3.all)$solutions,digits=c(3,3,3,0,3),caption="Fixed effects")
kable(summary(bivar3.all)$Gcovariances,digits=c(3,3,3,0),caption="Random effects")
kable(summary(bivar3.all)$Rcovariances,digits=c(3,3,3,0),caption="Random effects")
kable(diag(autocorr(bivar3.all$Sol)[2, , ]),caption="Autocorrelation")
kable(diag(autocorr(bivar3.all$VCV)[2, , ]),caption="Autocorrelation")
```

Among-individual correlation between intercepts and slopes for FFD, between FFD and fitness and between fitness and variation in slopes for FFD:

```{r fig.height=2.5, fig.width=6}
cor_bivar3.all_intslope <- 
  bivar3.all$VCV[,"at.level(variable, \"FFD\"):temp.id:at.level(variable, \"FFD\").id"]/
(sqrt(bivar3.all$VCV[,"at.level(variable, \"FFD\").id:at.level(variable, \"FFD\").id"])*
sqrt(bivar3.all$VCV[,"at.level(variable, \"FFD\"):temp.id:at.level(variable, \"FFD\"):temp.id"]))
posterior.mode(cor_bivar3.all_intslope)
HPDinterval(cor_bivar3.all_intslope)

cor_bivar3.all_intfit <-
  bivar3.all$VCV[,"at.level(variable, \"fitness\").id:at.level(variable, \"FFD\").id"]/
  (sqrt(bivar3.all$VCV[,"at.level(variable, \"fitness\").id:at.level(variable, \"fitness\").id"])*
     sqrt(bivar3.all$VCV[,"at.level(variable, \"FFD\").id:at.level(variable, \"FFD\").id"]))
posterior.mode(cor_bivar3.all_intfit)
HPDinterval(cor_bivar3.all_intfit)

cor_bivar3.all_slopefit <- 
  bivar3.all$VCV[,"at.level(variable, \"fitness\").id:at.level(variable, \"FFD\"):temp.id"]/
  (sqrt(bivar3.all$VCV[,"at.level(variable, \"fitness\").id:at.level(variable, \"fitness\").id"])*
     sqrt(bivar3.all$VCV[,"at.level(variable, \"FFD\"):temp.id:at.level(variable, \"FFD\"):temp.id"]))
posterior.mode(cor_bivar3.all_slopefit)
HPDinterval(cor_bivar3.all_slopefit)
```

Similar results as in previous models.

##### Extract selection coefficients

```{r fig.height=2.5, fig.width=6}
# Extract 3x3 matrix of variance-covariance values for intercepts and slopes 
# of temp, and fitness 
# These are in the 2nd-10th columns of model output
P.bivar3.all<- bivar3.all$VCV[,2:10]         
P.bivar3.all.mode <- matrix(1:9, nrow = 3)
for (k in 1:9) P.bivar3.all.mode[k] <- posterior.mode(P.bivar3.all
                                                    [,k])
P.bivar3.all.mode

# Extract selection *differentials* (i.e. covariances) for intercept and slope:
# and calculate posterior mode and credible intervals for each
S.bivar3.all <- bivar3.all$VCV[, c(4,7)]
S.bivar3.all <- P.bivar3.all[, c(3,6)] # This is exactly the same as above
colnames(S.bivar3.all) <- c("S_intercepts", "S_slopes")
S.bivar3.all.mode <- P.bivar3.all.mode[1:2, 3]
S.bivar3.all.mode
posterior.mode(mcmc(S.bivar3.all)) # This is exactly the same as above
HPDinterval(mcmc(S.bivar3.all))

# Estimate selection gradients for intercept and slope (beta = S / P)
# on each sample of posterior and extract their mode
n <- length(bivar3.all$VCV[,2])   # sample size
beta_post_bivar3.all <- matrix(NA, n ,2)

for (i in 1:n) {
  P3 <- matrix(rep(NA, 9), nrow = 3)  
  # 3x3 matrix of var-cov for individual X.int, X.slope and fitness
  for (k in 1:9) {P3[k] <- P.bivar3.all[i, k] }  
  P2 <- P3[1:2, 1:2]   # 2x2 matrix of just trait intercept & slope var-cov
  S <- P3[1:2, 3]   # selection differentials on traits (last column of P3)
  beta_post_bivar3.all[i,] <- solve(P2) %*% S   # selection gradients beta = P^-1 * S
}

# Finally, extract and plot the selection gradients posterior modes 
# and 95% credible intervals for both selection on intercepts (trait value) 
# and slopes (trait plasticity).

colnames(beta_post_bivar3.all) <- c("beta_intercepts", "beta_slopes")
posterior.mode(mcmc(beta_post_bivar3.all))
HPDinterval(mcmc(beta_post_bivar3.all))
```

The selection differentials are "significant" for RN intercept (negative) but not for slope. The selection gradients are significant for RN intercept (negative) but not for RN slope. This means that there is significant total and direct selection on the intercept of the RN.

#### With shoot volume

Stack data:

```{r}
# Create a single data-set "datadef.stack4", with single column at start 
# to index observations
datadef.stack4 <- c()
nrow(subset(datadef_total,!is.na(shoot_vol_mean))) # 791 ids with info on shoot_vol

nrow(subset(datadef,!is.na(FFD)&
              id %in% subset(datadef_total,!is.na(shoot_vol_mean))$id)) 
# 2432 cases with info on FFD and fitness 
# corresponding to the 791 ids with info on shoot_vol

# Check that those cases correspond to those 791 individuals
length(unique(subset(datadef,!is.na(FFD)&
         id %in% subset(datadef_total,!is.na(shoot_vol_mean))$id)$id))

datadef.stack4$Obs <- 1:(791 + 2432) 
datadef.stack4$id <- c(as.character(subset(datadef_total,!is.na(shoot_vol_mean))$id),
                      as.character(subset(datadef,!is.na(FFD)&
                            id %in% subset(datadef_total,!is.na(shoot_vol_mean))$id)$id)) 
# ids in alphabetical order

# Year column is only relevant for FFD, but is set to first_yr for fitness values
datadef.stack4$year <- c(subset(datadef_total,!is.na(shoot_vol_mean))$first_yr,
                         subset(datadef,!is.na(FFD)&
                                  id %in%subset(datadef_total,
                                                !is.na(shoot_vol_mean))$id)$year)

# Temperature column is only relevant for FFD, but is set to 0 for fitness values
datadef.stack4$temp <- c(rep(0, 791), 
                         subset(datadef,!is.na(FFD)&
                                  id %in%subset(datadef_total,
                                                !is.na(shoot_vol_mean))$id)$cmean_4)

# Shoot volume column is only relevant for fitness, but is set to 0 for FFD values
# Using sqrt of mean shoot volume over all years when available, centered
datadef.stack4$cn_shoot_vol <- c(subset(datadef_total,
                                        !is.na(shoot_vol_mean))$cn_shoot_vol_mean_sqrt,
                                 rep(0, 2432))

# Create single column with first fitness values (ABSOLUTE VALUES), then FFD values:
datadef.stack4$fitness.FFD.stack <- c(round(subset(datadef_total,
                                                   !is.na(shoot_vol_mean))$mean_fitness_study),
                                      subset(datadef,!is.na(FFD)&
                                               id %in%  subset(datadef_total,
                                                               !is.na(shoot_vol_mean))$id)$FFD)

# Create 3 index columns needed for MCMCglmm
datadef.stack4$traits <- as.factor(c(rep("fitness", 791), rep("FFD", 2432)))
datadef.stack4$variable <- as.factor(datadef.stack4$traits)
# Fitness will be modelled with an overdispersed Poisson 
# FFD will be modelled with a Gaussian distribution
# Specify this with the column 'family':
datadef.stack4$family <- c(rep("poisson", 791), rep("gaussian", 2432))
datadef.stack4 <- data.frame(datadef.stack4)

datadef.stack4$id <- as.factor(datadef.stack4$id)
datadef.stack4$year <- as.factor(datadef.stack4$year)
head(datadef.stack4)
```

```{r eval=FALSE, include=TRUE}
bivar4.all <- MCMCglmm(fitness.FFD.stack ~ variable - 1 +
                         # ^ means for each variable 
                         # (and no overall mean (hence "-1"))
                         at.level(variable, "FFD"):temp +  
                       # single fixed effect of temp
                         at.level(variable,"fitness"):cn_shoot_vol,
                       random = ~us(at.level(variable, "FFD")):year +
                         us(at.level(variable, "FFD") + 
                              at.level(variable,"FFD"):temp):id,
                       # ^ random intercepts for individual, 
                       # and random slopes for temp|id
                       rcov = ~us(at.level(variable, "fitness")):id + 
                         # ^ variance between indivdiuals in fitness
                         # (which is residual variance)
                         us(at.level(variable, "FFD")):Obs,    
                         # ^ residual variance within indivdiuals between years 
                       # (labelled by 'Obs')
                       data = datadef.stack4,
                       prior = priorBiv, 
                       family = NULL, # specified already in the data-set
                       nitt = 2100 * sc, thin = sc, burnin = 100 * sc, 
                       verbose = F,singular.ok = T) 
# nitt = burnin + thin*(n samples to keep)
# Aim to store 2000 iterations
save(bivar4.all,file="output/bivar4.all.RData")
```

```{r}
kable(summary(bivar4.all)$solutions,digits=c(3,3,3,0,3),caption="Fixed effects")
kable(summary(bivar4.all)$Gcovariances,digits=c(3,3,3,0),caption="Random effects")
kable(summary(bivar4.all)$Rcovariances,digits=c(3,3,3,0),caption="Random effects")
kable(diag(autocorr(bivar4.all$Sol)[2, , ]),caption="Autocorrelation")
kable(diag(autocorr(bivar4.all$VCV)[2, , ]),caption="Autocorrelation")
```

Among-individual correlation between intercepts and slopes for FFD, between FFD and fitness and between fitness and variation in slopes for FFD:

```{r fig.height=2.5, fig.width=6}
cor_bivar4.all_intslope <- 
  bivar4.all$VCV[,"at.level(variable, \"FFD\"):temp.id:at.level(variable, \"FFD\").id"]/
(sqrt(bivar4.all$VCV[,"at.level(variable, \"FFD\").id:at.level(variable, \"FFD\").id"])*
sqrt(bivar4.all$VCV[,"at.level(variable, \"FFD\"):temp.id:at.level(variable, \"FFD\"):temp.id"]))
posterior.mode(cor_bivar4.all_intslope)
HPDinterval(cor_bivar4.all_intslope)

cor_bivar4.all_intfit <-
  bivar4.all$VCV[,"at.level(variable, \"fitness\").id:at.level(variable, \"FFD\").id"]/
  (sqrt(bivar4.all$VCV[,"at.level(variable, \"fitness\").id:at.level(variable, \"fitness\").id"])*
     sqrt(bivar4.all$VCV[,"at.level(variable, \"FFD\").id:at.level(variable, \"FFD\").id"]))
posterior.mode(cor_bivar4.all_intfit)
HPDinterval(cor_bivar4.all_intfit)

cor_bivar4.all_slopefit <- 
  bivar4.all$VCV[,"at.level(variable, \"fitness\").id:at.level(variable, \"FFD\"):temp.id"]/
  (sqrt(bivar4.all$VCV[,"at.level(variable, \"fitness\").id:at.level(variable, \"fitness\").id"])*
     sqrt(bivar4.all$VCV[,"at.level(variable, \"FFD\"):temp.id:at.level(variable, \"FFD\"):temp.id"]))
posterior.mode(cor_bivar4.all_slopefit)
HPDinterval(cor_bivar4.all_slopefit)
```

Similar results as in previous models.

##### Extract selection coefficients

```{r fig.height=2.5, fig.width=6}
# Extract 3x3 matrix of variance-covariance values for intercepts and slopes 
# of temp, and fitness 
# These are in the 2nd-10th columns of model output
P.bivar4.all<- bivar4.all$VCV[,2:10]         
P.bivar4.all.mode <- matrix(1:9, nrow = 3)
for (k in 1:9) P.bivar4.all.mode[k] <- posterior.mode(P.bivar4.all
                                                    [,k])
P.bivar4.all.mode

# Extract selection *differentials* (i.e. covariances) for intercept and slope:
# and calculate posterior mode and credible intervals for each
S.bivar4.all <- bivar4.all$VCV[, c(4,7)]
S.bivar4.all <- P.bivar4.all[, c(3,6)] # This is exactly the same as above
colnames(S.bivar4.all) <- c("S_intercepts", "S_slopes")
S.bivar4.all.mode <- P.bivar4.all.mode[1:2, 3]
S.bivar4.all.mode
posterior.mode(mcmc(S.bivar4.all)) # This is exactly the same as above
HPDinterval(mcmc(S.bivar4.all))

# Estimate selection gradients for intercept and slope (beta = S / P)
# on each sample of posterior and extract their mode
n <- length(bivar4.all$VCV[,2])   # sample size
beta_post_bivar4.all <- matrix(NA, n ,2)

for (i in 1:n) {
  P3 <- matrix(rep(NA, 9), nrow = 3)  
  # 3x3 matrix of var-cov for individual X.int, X.slope and fitness
  for (k in 1:9) {P3[k] <- P.bivar4.all[i, k] }  
  P2 <- P3[1:2, 1:2]   # 2x2 matrix of just trait intercept & slope var-cov
  S <- P3[1:2, 3]   # selection differentials on traits (last column of P3)
  beta_post_bivar4.all[i,] <- solve(P2) %*% S   # selection gradients beta = P^-1 * S
}

# Finally, extract and plot the selection gradients posterior modes 
# and 95% credible intervals for both selection on intercepts (trait value) 
# and slopes (trait plasticity).

colnames(beta_post_bivar4.all) <- c("beta_intercepts", "beta_slopes")
posterior.mode(mcmc(beta_post_bivar4.all))
HPDinterval(mcmc(beta_post_bivar4.all))
```

The selection differentials are "significant" for RN intercept (negative), but not for RN slope. The selection gradients are significant for both RN intercept (negative) and slope (positive).

## brms

### Mean fitness per flowering event

#### With no condition variable

I tried to use the ID-syntax to specify fitness to be correlated with the intercept and slope of FFD on temperature - check that this is correctly done!

Regarding distributions, I tried Poisson distribution for fitness, but not sure how eventual overdispersion is handled. I also tried adding an observation-level random effect, and using a negative binomial distribution. Results seem quite similar.

##### Poisson distribution

```{r message=FALSE, warning=FALSE}
datadef<-left_join(datadef,datadef_total[c(1:3,9)]) # Add info on mean fitness and mean shoot volume
bf_fitness <- bf(round(mean_fitness_fl) ~  (1|ID1|id)) # Set up model formula
bf_FFD <- bf(FFD ~ cmean_4 + (cmean_4|ID1|id) + (1|year)) # Set up model formula
# Specifying group-level effects of the same grouping factor (id here) to be correlated across formulas
# Expand the | operator into |<ID>|, where <ID> can be any value (ID1 here)
# Group-level terms with the same ID1 will be modeled as correlated if they share same grouping factor(s)
```

```{r eval=FALSE, message=FALSE, warning=FALSE, include=TRUE}
bivar1.all.brm.pois<-brm(bf_fitness + bf_FFD, family = c(poisson, gaussian), data = datadef,
                warmup = 1000,iter = 4000,chains=4,thin=2,
                inits = "random",seed = 12345,cores = my.cores)
# Total of 6000 post-warmup samples
save(bivar1.all.brm.pois,
     file="output/bivar1.all.brm.pois.RData")
```

```{r}
summary(bivar1.all.brm.pois)
```

###### How to extract selection coefficients from models fitted with brms?

##### Poisson distribution, observation-level random effect

```{r}
datadef$OLRE<-seq_len(nrow(datadef))
bf_fitness_OLRE <- bf(round(mean_fitness_fl) ~  (1|ID1|id) + (1|OLRE))
bf_FFD_OLRE <- bf(FFD ~ cmean_4 + (cmean_4|ID1|id) + (1|year) + (1|OLRE))
```

```{r, eval=FALSE, include=TRUE}
bivar1.all.brm.OLRE<-brm(bf_fitness_OLRE + bf_FFD_OLRE, family = c(poisson, gaussian),
                         data = datadef,warmup = 1000,iter = 4000,chains=4,thin=2,
                         inits = "random",seed = 12345,cores = my.cores)
# Model gives some warnings - not sure what the problems are!
save(bivar1.all.brm.OLRE,
     file="output/bivar1.all.brm.OLRE.RData")
```

```{r}
summary(bivar1.all.brm.OLRE)
```

##### Negative binomial distribution

```{r, eval=FALSE, include=TRUE}
bivar1.all.brm.nb<-brm(bf_fitness + bf_FFD, family = c(negbinomial, gaussian), 
                       data = datadef,warmup = 1000,iter = 4000,chains=4,thin=2,
                         inits = "random",seed = 12345,cores = my.cores)
# No warnings, so maybe the way to go to account for overdispersion?
save(bivar1.all.brm.nb,
     file="output/bivar1.all.brm.nb.RData")
```

```{r}
summary(bivar1.all.brm.nb)
```

#### With shoot volume

Tried only with negative binomial distribution so far.

```{r message=FALSE, warning=FALSE}
bf_fitness_shoot <- bf(round(mean_fitness_fl) ~  cn_shoot_vol_mean_sqrt +
                         (1|ID1|id)) # Set up model formula
```

```{r, eval=FALSE, include=TRUE}
bivar2.all.brm.nb<-brm(bf_fitness_shoot + bf_FFD, 
                       family = c(negbinomial, gaussian), 
                       data = datadef,warmup = 1000,iter = 4000,chains=4,thin=2,
                         inits = "random",seed = 12345,cores = my.cores)
save(bivar2.all.brm.nb,
     file="output/bivar2.all.brm.nb.RData")
```

```{r}
summary(bivar2.all.brm.nb)
```

### Mean fitness per year of study

#### With no condition variable

Tried only with negative binomial distribution so far.

```{r message=FALSE, warning=FALSE}
bf_fitness_study <- bf(round(mean_fitness_study) ~  (1|ID1|id)) 
# Set up model formula
```

```{r, eval=FALSE, include=TRUE}
bivar3.all.brm.nb<-brm(bf_fitness_study + bf_FFD, 
                       family = c(negbinomial, gaussian), 
                       data = datadef,warmup = 1000,iter = 4000,chains=4,thin=2,
                         inits = "random",seed = 12345,cores = my.cores)
save(bivar3.all.brm.nb,
     file="output/bivar3.all.brm.nb.RData")
```

```{r}
summary(bivar3.all.brm.nb)
```

#### With shoot volume

Tried only with negative binomial distribution so far.

```{r message=FALSE, warning=FALSE}
bf_fitness_study_shoot <- bf(round(mean_fitness_study) ~  
                               cn_shoot_vol_mean_sqrt +
                         (1|ID1|id)) # Set up model formula
```

```{r, eval=FALSE, include=TRUE}
bivar4.all.brm.nb<-brm(bf_fitness_study_shoot + bf_FFD, 
                       family = c(negbinomial, gaussian), 
                       data = datadef,warmup = 1000,iter = 4000,chains=4,thin=2,
                         inits = "random",seed = 12345,cores = my.cores)
save(bivar4.all.brm.nb,
     file="output/bivar4.all.brm.nb.RData")
```

```{r}
summary(bivar4.all.brm.nb) 
```

## Compare results of MCMCglmm and brms

I am not sure the code for this comparison is correct, the code needs checking! Therefore, I only performed the comparison for models with mean fitness per flowering event and no condition variable so far.

### Mean fitness per flowering event, no condition variable

```{r}
kable(data.frame(summary(bivar1.all)$solutions)[1]) # Fixed effects MCMCglmm
kable(data.frame(summary(bivar1.all.brm.nb)$fixed)[1]) # Fixed effects brms

bivar1.all.brm.nb_asmcmc <- as.mcmc(bivar1.all.brm.nb, combine_chains = TRUE)
#head(bivar1.all.brm.nb_asmcmc) # check which column the parameters are in

bivar1.all.brm.nb_year <- (bivar1.all.brm.nb_asmcmc[,7]^2)  
# sd_year__Intercept^2

bivar1.all.brm.nb_id_intercept_FFD <- (bivar1.all.brm.nb_asmcmc[,5]^2)  
# sd(FFD_Intercept)^2 (individual intercept for FFD)

bivar1.all.brm.nb_cor_intercept_slope<-(bivar1.all.brm.nb_asmcmc[,10]^2) 
# cor(FFD_Intercept,FFD_cmean_4)^2 (corr intercept for FFD - slope for FFD)

bivar1.all.brm.nb_cor_intercept_fitness<-(bivar1.all.brm.nb_asmcmc[,8]^2) 
# cor(roundmeanfitnessfl_Intercept,FFD_Intercept)^2 (corr intercept FFD - fitness)

# cor(FFD_Intercept,FFD_cmean_4)^2 (corr intercept for FFD - slope for FFD) (rep)

bivar1.all.brm.nb_id_slope_FFD <- (bivar1.all.brm.nb_asmcmc[,6]^2)  
# sd(FFD_cmean_4)^2 (individual slope for FFD)

bivar1.all.brm.nb_cor_slope_fitness<-(bivar1.all.brm.nb_asmcmc[,9]^2) 
# cor(roundmeanfitnessfl_Intercept,FFD_cmean_4)^2 (corr slope for FFD - fitness)

# cor(roundmeanfitnessfl_Intercept,FFD_Intercept)^2 (corr intercept for FFD - fitness) (rep)

# cor(roundmeanfitnessfl_Intercept,FFD_cmean_4)^2 (corr slope for FFD - fitness) (rep)

bivar1.all.brm.nb_intercept_fitness<-(bivar1.all.brm.nb_asmcmc[,4]^2) 
# sd(roundmeanfitnessfl_Intercept)^2 (intercept for fitness)

bivar1.all.brm.nb_resid<-(bivar1.all.brm.nb_asmcmc[,12]^2) 
# sigma_FFD^2 (residual)

compar_bivar1<-cbind(MCMCglmm=summary(bivar1.all$VCV)$statistics[,1],
      brms=as.vector(cbind(mean(bivar1.all.brm.nb_year),
                           mean(bivar1.all.brm.nb_id_intercept_FFD),
                           mean(bivar1.all.brm.nb_cor_intercept_slope),
                           -mean(bivar1.all.brm.nb_cor_intercept_fitness),
                           mean(bivar1.all.brm.nb_cor_intercept_slope),
                           mean(bivar1.all.brm.nb_id_slope_FFD),
                           -mean(bivar1.all.brm.nb_cor_slope_fitness),
                           -mean(bivar1.all.brm.nb_cor_intercept_fitness),
                           -mean(bivar1.all.brm.nb_cor_slope_fitness),
                           mean(bivar1.all.brm.nb_intercept_fitness),
                           mean(bivar1.all.brm.nb_resid))))
# Comparison random effects
compar_bivar1<-compar_bivar1[c(1:4,6:7,10:11),]
row.names(compar_bivar1)<-c("year_FFD",
                          "id_var_intercept_FFD",
                          "id_covar_intercept_slope_FFD",
                          "id_covar_fitness_intercept_FFD",
                          "id_var_slope_FFD",
                          "id_covar_fitness_slope_FFD",
                          "id_var_intercept_fitness",
                          "residual")
kable(compar_bivar1)
```

TO DO: run again the analyses with the BLUPs to test for variation in selection among years with all the individuals

```{r include=FALSE}
sessionInfo()
```
